import paramiko
from sys import stdout
from socket import error as socket_error
import os
import posixpath


class SSHManage:

    # Initialize module - default output is STDOUT
    def __init__(self):
        self.remote_address = ''
        self.remote_user = ''
        self.remote_password = ''
        self.remote_password = ''
        self.remote_port = ''
        self.client = None
        self.sftp = None
        self.logfile = stdout

    # Set SSH/SFTP module logfile to <logfile_path>
    def set_logfile(self, logfile_path):
        self.logfile = open(logfile_path, 'w')

    # Set SSH/SFTP module logfile to default name in <logfile_directory>
    def set_logfile_by_directory(self, logfile_directory):
        self.logfile = open(os.path.join(logfile_directory, 'ssh_wrapper.log'), 'w')

    # Flush SSH/SFTP module logfile
    def flush_logfile(self):
        self.logfile.flush()

    # Configure user-supplied values for ssh/sftp connection <ip, user, pass, port>
    def configure_connection(self, ip_address, username, password, port=22):
            self.remote_address = ip_address
            self.remote_user = username
            self.remote_password = password
            self.remote_port = port

    # Start connection via Paramiko wrapper
    def start_connection(self):
        try:
            self.client = paramiko.SSHClient()
            self.client.load_system_host_keys()
            self.client.set_missing_host_key_policy(paramiko.WarningPolicy())
            self.client.connect(hostname=self.remote_address, username=self.remote_user, password=self.remote_password,
                                port=self.remote_port)
            return 1
        except socket_error:
            self.logfile.write('Failed to establish a connection to {}\n'.format(self.remote_address))
            return 0
        except paramiko.BadHostKeyException:
            self.logfile.write('Host could not be verified {}\n'.format(self.remote_address))
            return 0
        except paramiko.AuthenticationException:
            self.logfile.write('Failed to authenticate on {} using the username {} and password '
                               'provided\n'.format(self.remote_address, self.remote_password))
            return 0
        except paramiko.SSHException:
            self.logfile.write('Problems with SSH in attempt to connect to {}\n'.format(self.remote_address))
            return 0
        except Exception as e:
            self.logfile.write('Unknown exception {} in attempt to establish connection to {}\n'.format(e,
                               self.remote_address))
            raise

    # Start SFTP connection (requires start_connection first)
    def start_sftp(self):
        self.sftp = self.client.open_sftp()

    # Close SFTP connection
    def close_sftp(self):
        self.sftp.close()
        self.sftp = None

    # Put a single file via the SFTP connection
    def put(self, input_path, output_path):
        self.sftp.put(input_path, output_path)

    # Put <input_directory> via the SFTP connection. Special behavior: if <output_directory> exists, delete the
    # directory. Put <input_directory> to <output_directory>. Currently only configured to handle Windows targets
    def delete_recreate_and_put_directory(self, input_directory, output_ftp_directory, output_directory, os_type):
        if os_type == 'windows':
            self.send_command('del /q /s {}'.format(output_directory))
            self.send_command('rd /q /s {}'.format(output_directory))
        self.create_and_put_directory(input_directory, output_ftp_directory)

    # Checks to see if <output_directory> exists on target machine, creates <output_directory> if it does not exist,
    # put files from <input_directory> on target machine
    def create_and_put_directory(self, input_directory, output_directory):
        try:
            self.sftp.chdir(output_directory)  # Test if remote_path exists
        except (IOError, FileNotFoundError):
            self.make_directory(output_directory)  # Create remote_path
            self.sftp.chdir(output_directory)
        self.put_directory(input_directory, output_directory)

    # Uploads the contents of <input_directory> to <output_directory>. The target directory needs to exists. All
    # subdirectories in source are created under target.
    def put_directory(self, input_directory, output_directory):
        for item in os.listdir(input_directory):
            local_path = os.path.join(input_directory, item)
            remote_path = posixpath.join(output_directory, item)
            if os.path.isfile(local_path):
                self.sftp.put(local_path, remote_path)
            else:
                self.make_directory(remote_path)
                self.put_directory(local_path, remote_path)

    # Augments mkdir by adding an option to not fail if the folder exists
    def make_directory(self, path, mode=511, ignore_existing=False):
        try:
            self.logfile.write("{}\n".format(path))
            self.sftp.mkdir(path, mode)
        except IOError:
            if ignore_existing:
                pass
            else:
                raise

    # Send <command> via SSH to the target machine
    def send_command(self, command):
        try:
            stdin, stdout, stderr = self.client.exec_command(command)
            return stdout.read().decode('ascii')
        except paramiko.SSHException:
            self.logfile.write('Failed to execute command {} on {}\n'.format(command, self.remote_address))
            return ''
        except Exception as e:
            self.logfile.write('Unknown exception {} in attempt to establish connection to {}\n'.format(e,
                               self.remote_address))
            raise

    # Send a sudo  command via SSH to the target machine
    def send_sudo_command(self, command, password):
        try:
            stdin, stdout, stderr = self.client.exec_command(command)
            stdin.write(password + '\n')
            stdin.flush()
            return stdout.read().decode('ascii')
        except paramiko.SSHException:
            self.logfile.write('Failed to execute command {} on {}\n'.format(command, self.remote_address))
            return ''
        except Exception as e:
            self.logfile.write('Unknown exception {} in attempt to establish connection to {}\n'.format(e,
                               self.remote_address))
            raise

    # Close connections and module logfile
    def close(self):
        if self.sftp:
            self.close_sftp()
        if self.client:
            self.client.close()
            self.client = None
        if self.logfile != stdout:
            self.logfile.close()
        return 1
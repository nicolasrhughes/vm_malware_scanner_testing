import forensic_wrapper as fw
import virus_scanner_wrapper as vs
import argparse
from os import path
from os import mkdir
from sys import stdout
from datetime import datetime

class EvaluationUtilities:

    # These values are used to specify whether data is sent to STDOUT or to logfiles stored under the project directory
    MODULE_LOGGING = 4
    MAIN_LOGGING = 2
    NO_LOGGING = 0

    def __init__(self):
        self.logfile = stdout
        self.config = {}
        self.fw_object = None
        self.vs_object = None
        self.mount_path = ''
        self.noriben_path = ''
        self.loop_device = ''
        self.exe_file = ''
        self.time_string = datetime.now().strftime('%Y-%m-%d_%H%M%S')
        self.files = []
        self.registry_entries = []
        self.module_logging = False

    def set_logging(self, logging_type):
        if not self.config:
            raise AttributeError('Logging requested before specifying log configuration')
        if (logging_type and self.MAIN_LOGGING) == self.MAIN_LOGGING:
            self.logfile = open(path.join(self.config['log_path'], self.time_string + '__main__' + '.log'), 'w')
        if (logging_type and self.MODULE_LOGGING) == self.MODULE_LOGGING:
            self.module_logging = True

    # This function processes the input configuration file, stores the data in a dictionary, and computes some new
    # values based on the project directory. It also converts some strings to numerical data
    def process_config(self, filename):
        self.config = {}
        with open(filename) as config_file:
            for line in config_file:
                variable, value = line.strip().split(': ', 1)
                self.config[variable] = value
        if not path.isdir(self.config['project_path']):
            mkdir(self.config['project_path'])
        self.config['log_path'] = path.join(self.config['project_path'], 'log')
        EvaluationUtilities.check_or_make_path(self.config['log_path'])
        self.config['reference_path'] = path.join(self.config['project_path'], 'reference')
        EvaluationUtilities.check_or_make_path(self.config['reference_path'])
        self.config['output_path'] = path.join(self.config['project_path'], 'output')
        EvaluationUtilities.check_or_make_path(self.config['output_path'])
        self.config['image_path'] = path.join(self.config['project_path'], 'image')
        EvaluationUtilities.check_or_make_path(self.config['image_path'])
        return self.config

    # This function simply returns the image path (where the vm disk images to be processed live)
    def get_image_path(self, error_string='No configuration file specified. Use process_config before proceeding.'):
        if not self.config:
            raise AttributeError(error_string)
        return self.config['image_path']

    # This function returns the list of virus scanners listed in the config file
    def get_virus_scanners(self, error_string='No configuration file specified. Use process_config before proceeding.'):
        if not self.config:
            raise AttributeError(error_string)
        return self.config['virus_scanners']

    @staticmethod
    def parse_config_file():
        parser = argparse.ArgumentParser(description='Create malware-infected VM images for tool testing. Please read '
                                                     'README.md for more details.')
        parser.add_argument('config_file', metavar='configuration_file', type=str, nargs='?',
                            help='Path to configuration file. The program assumes the config is located'
                                 ' at ./config.txt if no configuration file is specified.')
        return parser.parse_args()

    # Checks to see if Noriben file has been ingested
    def config_check(self, error_string='No Noriben file has been ingested. Call ingest_noriben_data before'
                                        'proceeding'):
        if not self.config:
            raise AttributeError(error_string)

    def exe_check(self, error_string='No virus has been associated with the file. Use ingest_noriben_csv before'
                                     'proceeding'):
        if not self.exe_file:
            raise AttributeError(error_string)

    def check_or_create_forensic_wrapper(self):
        if not self.fw_object:
            self.fw_object = fw.ForensicUtility()
            if self.module_logging:
                if self.exe_basename:
                    self.fw_object.set_logfile(path.join(self.config['log_path'], self.exe_basename + '_' + self.time_string
                                                         + '__forensic__' + '.log'))
                else:
                    self.fw_object.set_logfile(path.join(self.config['log_path'], self.time_string + '__forensic__'
                                                         + '.log'))
            return False
        else:
            return True

    def check_or_configure_virus_scanner_wrapper(self, tool):
        if not self.vs_object:
            self.vs_object = vs.VirusScannerTesting()
        else:
            self.vs_object.close_logfile()
            self.vs_object.close_output()
        if self.module_logging:
            self.vs_object.set_logfile(path.join(self.config['log_path'], self.exe_file + "_" + self.time_string +
                                                 '__{}__'.format(tool) + '.log'))
            self.vs_object.set_output(path.join(self.config['output_path'], self.exe_file + "_" + self.time_string +
                                                '__{}__'.format(tool) + '.log'))

    # DELETE ME AFTER TESTING
    # This function is used to speed up testing and should be removed from the final version. It simply allows the
    # user to set the mount_path and the noriben path (derived from mount_path) variables.
    def set_mount_path(self, supplied_path):
        self.mount_path = supplied_path
        self.noriben_path = self.windows_path_to_local_path(self.config['remote_path'])

    # DELETE ME AFTER TESTING
    # This function is used to speed up testing and should be removed from the final version. It simply allows the
    # user to set the virus executable file name (which is used for logging)
    def set_exe_file(self, supplied_path):
        self.exe_file = supplied_path

    # This function uses udisksctl to automagically detect the underlying partition structure of the vm disk
    # and to map the disk image to loop back. The function then mounts partition 2 (the C:\ drive of the vm disk)
    # and returns the path of the mounted disk image. This function operates in userspace and does not require root
    def safemount_image(self, image_file):
        self.config_check('You must process the configuration file with process_config before attempting to mount '
                          'the VM image')
        if not self.fw_object:
            self.fw_object = fw.ForensicUtility()
        self.logfile.write('Attempting to mount {}\n'.format(image_file))
        self.loop_device, self.mount_path = self.fw_object.safemount_image(image_file)
        if self.mount_path:
            self.noriben_path = self.windows_path_to_local_path(self.config['remote_path'])
            self.logfile.write('Successfully mounted {} as {}\n'.format(image_file, self.mount_path))
            return True
        elif self.loop_device:
            self.fw_object.delete_loop(self.loop_device)
            raise IOError('Failed to mount {} from loop device \n'.format(image_file))
        else:
            raise IOError('Failed to setup loop device from {} \n'.format(image_file))
            
    # This function unmounts the loopback device, then deletes the loopback device.
    def unmount_image(self):
        self.logfile.write('Attempting to unmount and remove block device associated with {}\n'.format(self.mount_path))
        if not self.loop_device:
            raise AttributeError('No loopback device to unmount/delete')
        self.fw_object.unmount_image(self.loop_device)
        self.fw_object.delete_loop(self.loop_device)
        self.mount_path = ''
        self.loop_device = ''
        return False

    # This function finds the Noriben timeline CSV stored in the noriben_path and ingests the File and Registry entries,
    # which are stored as a list of lists in files and registry_entries respectively. Catches a IO error raised if the
    # file is not found or opened. Because we don't know what virus was executed before running this module, we use a
    # temporary logfile if module_logging is enabled
    def ingest_noriben_data(self):
        self.config_check()
        set_logfile = False
        if not self.check_or_create_forensic_wrapper():
            set_logfile = True
        try:
            self.files, self.registry_entries, self.exe_file = self.fw_object.ingest_noriben_data(self.noriben_path)
        except IOError:
            return False
        self.exe_file = path.splitext(self.exe_file)[0]
        if set_logfile and self.module_logging:
            self.fw_object.close_logfile()
            self.fw_object.set_logfile(path.join(self.config['log_path'], self.exe_file + '_' + self.time_string +
                                                 '__forensic__' + '.log'))
        if self.exe_file:
            return True
        else:
            return False

    # Since we are looking at a timeline, we are trying to find the last entry to find (we don't care if the same)
    # entry was overwritten or was deleted and recreated, we just want to know where the file *should* exist in the
    # file structure or not.
    def classify_files_from_noriben_csv(self):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.classify_files_from_noriben_csv(self.files)

    # Since we are looking at a timeline, we are trying to find the last entry to find (we don't care if the same)
    # entry was overwritten or was deleted and recreated, we just want to know where the file *should* exist in the
    # file structure or not.
    def classify_registry_entries_from_noriben_csv(self):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.classify_registry_entries_from_noriben_csv(self.registry_entries)

    @staticmethod
    def check_or_make_path(target_path):
        if not path.isdir(target_path):
            mkdir(target_path)

    # This function does two main things: first, it parses a list of noriben entries (either file list or self.file list
    # into local paths and tries to copy those files. Then, the function saves a log of what it could and could not find
    # in csv format. If deleted_list is supplied, a log is made of those files, too
    def process_file_list(self, file_list=None, deleted_list=None):
        self.config_check()
        self.exe_check()
        self.check_or_create_forensic_wrapper()
        reference_dir = path.join(self.config['reference_path'], self.exe_file + '_' + self.time_string)
        reference_log_list = []
        if file_list:
            compare_list = file_list
        else:
            compare_list = self.files
        processed_files = self.translate_windows_special_directories(compare_list)
        EvaluationUtilities.check_or_make_path(reference_dir)
        reference_dir = path.join(reference_dir, "Files")
        EvaluationUtilities.check_or_make_path(reference_dir)
        for i in range(len(processed_files)):
            local_path = self.windows_path_to_local_path(processed_files[i])
            try:
                if path.isfile(local_path):
                    reference_path = path.join(reference_dir, path.basename(local_path))
                    if self.fw_object.copy_and_verify_file(local_path, reference_path):
                        reference_log_list.append([compare_list[i][3], local_path, 'Y'])
                else:
                    reference_log_list.append([compare_list[i][3], local_path, 'N'])
            except IOError:
                print('Could not open {}'.format(local_path))
        process_dir = path.join(reference_dir, "Logs")
        process_log = path.join(process_dir, '{}.created_files.log'.format(self.exe_file))
        EvaluationUtilities.check_or_make_path(process_dir)
        if reference_log_list:
            with open(process_log, 'w') as process_log_file:
                for entry in reference_log_list:
                    for value in entry:
                        process_log_file.write('{},'.format(value))
                    process_log_file.write('\n')
        if deleted_list:
            process_log = path.join(process_dir, '{}.deleted_files.log'.format(self.exe_file))
            with open(process_log, 'w') as process_log_file:
                processed_files = self.translate_windows_special_directories(deleted_list)
                for i in range(len(deleted_list)):
                    local_path = self.windows_path_to_local_path(processed_files[i])
                    process_log_file.write("{},{},\n".format(deleted_list[i][3], local_path))

    # This function does two main things: first, it parses a list of noriben entries (either file list or self.file list
    # into local paths and tries to copy those files. Then, the function saves a log of what it could and could not find
    # in csv format. If deleted_list is supplied, a log is made of those files, too. This function is much like
    # process_file_list, but it is geared toward registry entries.
    def process_registry_list(self, registry_entries_list, deleted_entries_list):
        self.config_check()
        self.exe_check()
        self.check_or_create_forensic_wrapper()
        reference_dir = path.join(self.config['reference_path'], self.exe_file + '_' + self.time_string)
        if registry_entries_list:
            compare_list = registry_entries_list
        else:
            compare_list = self.registry_entries
        EvaluationUtilities.check_or_make_path(reference_dir)
        reference_dir = path.join(reference_dir, "Registry")
        EvaluationUtilities.check_or_make_path(reference_dir)
        entry_list = []
        found_list = []
        for entry in compare_list:
            try:
                registry_file, registry_entry = self.registry_association(entry[5])
                key, separator, subkey = registry_entry.rpartition("\\")
                value = self.get_registry_entry(registry_file, key, subkey)
                if value:
                    found_list.append([registry_file, registry_entry, value])
                    entry_list.append([registry_file, registry_entry, 'Y', value])
                else:
                    entry_list.append([registry_file, registry_entry, 'N', ''])
            except Exception as e:
                print(entry)
                raise e
        values_path = path.join(reference_dir, "{}_created_registry_values.log".format(self.exe_file))
        if found_list:
            with open(values_path, 'w') as output_file:
                for entry in found_list:
                    for value in entry:
                        output_file.write('{},'.format(value))
                    output_file.write('\n')
        process_dir = path.join(reference_dir, "Logs")
        process_log = path.join(process_dir, '{}.created_registry_entries.log'.format(self.exe_file))
        EvaluationUtilities.check_or_make_path(process_dir)
        with open(process_log, 'w') as process_log_file:
            for entry in entry_list:
                for value in entry:
                    process_log_file.write('{},'.format(value))
                process_log_file.write('\n')
        if deleted_entries_list:
            process_log = path.join(process_dir, '{}.deleted_registry_entries.log'.format(self.exe_file))
            with open(process_log, 'w') as process_log_file:
                for i in range(len(deleted_entries_list)):
                    registry_file, registry_entry = self.registry_association(deleted_entries_list[i][5])
                    process_log_file.write("{},{},\n".format(registry_file, registry_entry))

    # This function prunes the drive designation (C:\) and any leading forward slashes from a path, then converts
    # the path to a path traversable on the local machine, using the mount point as the root
    def windows_path_to_local_path(self, file_path):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.windows_path_to_local_path(self.mount_path, file_path)

    # This function maps registry key entries to the mounted vm drive. No logging currently implemented (low value,
    # verbosity)
    def registry_association(self, key):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.get_registry_association(self.mount_path, key)

    # This function maps registry key entries to the mounted vm drive. No logging currently implemented (low value,
    # verbosity)
    def get_registry_entry(self, registry_path, key, subkey):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.get_registry_entry(registry_path, key, subkey)

    # This function Windows path variables (%APPDATA%) to paths
    def translate_windows_special_directories(self, file_list=None):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        if file_list:
            processed_output = self.fw_object.translate_windows_special_directories(file_list, self.config)
        else:
            processed_output = self.fw_object.translate_windows_special_directories(self.files, self.config)
        return processed_output

    # This function attempts to execute the specified tool on the mounted disk
    def execute_tool(self, tool, target_path=None):
        self.config_check()
        if target_path:
            tool_path = target_path
        else:
            tool_path = self.mount_path
        self.check_or_configure_virus_scanner_wrapper(tool)
        self.logfile.write('Invoking {} on {}.\n'.format(tool, tool_path))
        tool_id = self.vs_object.get_tool_id(tool)
        if self.vs_object.execute_tool_test(tool_id, tool_path):
            return True
        else:
            return False

    def execute_virus_scanners(self, target_path=None):
        for virus_scanner in self.config['virus_scanners'].split(','):
            self.execute_tool(virus_scanner, target_path)

    def close(self):
        if self.mount_path:
            self.fw_object.unmount_image(self.loop_device)
        if self.loop_device:
            self.fw_object.delete_loop(self.loop_device)
        if self.logfile != stdout:
            self.logfile.close()
        if self.fw_object:
            self.fw_object.close()
        if self.vs_object:
            self.vs_object.close()

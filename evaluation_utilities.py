import forensic_wrapper as fw
import virus_scanner_wrapper as vs
import external_wrapper as ew
import argparse
from os import path
from os import mkdir
from sys import stdout
from datetime import datetime
from shutil import copy
from subprocess import run, PIPE


class EvaluationUtilities:

    # These values are used to specify whether data is sent to STDOUT or to logfiles stored under the project directory
    MODULE_LOGGING = 4
    MAIN_LOGGING = 2
    NO_LOGGING = 0

    MALICE_SCANNERS = ['malice/avast', 'malice/avg', 'malice/clamav', 'malice/comodo', 'malice/escan', 'malice/fprot',
                       'malice/fsecure', 'malice/mcafee', 'malice/sophos', 'malice/windows-defender', 'malice/zoner']

    def __init__(self):
        self.logfile = stdout
        self.config = {}
        self.fw_object = None
        self.vs_object = None
        self.ew_object = None
        self.base_name = ''
        self.mount_path = ''
        self.noriben_path = ''
        self.loop_device = ''
        self.exe_file = ''
        self.full_exe_file = ''
        self.time_string = datetime.now().strftime('%Y-%m-%d_%H%M%S')
        self.files = []
        self.registry_entries = []
        self.module_logging = False

    # Set both main and module logging. This module uses main logging.
    def set_logging(self, logging_type):
        if not self.config:
            raise AttributeError('Logging requested before specifying log configuration')
        if (logging_type and self.MAIN_LOGGING) == self.MAIN_LOGGING:
            self.logfile = open(path.join(self.config['log_path'], self.time_string + '__main__' + '.log'), 'w')
        if (logging_type and self.MODULE_LOGGING) == self.MODULE_LOGGING:
            self.module_logging = True

    # This function processes the input configuration file, stores the data in a dictionary, and computes some new
    # values based on the project directory. It also converts some strings to numerical data
    def process_config(self, filename):
        self.config = {}
        with open(filename) as config_file:
            for line in config_file:
                variable, value = line.strip().split(': ', 1)
                self.config[variable] = value
        if not path.isdir(self.config['project_path']):
            mkdir(self.config['project_path'])
        self.config['log_path'] = path.join(self.config['project_path'], 'log')
        EvaluationUtilities.check_or_make_path(self.config['log_path'])
        self.config['output_path'] = path.join(self.config['project_path'], 'output')
        EvaluationUtilities.check_or_make_path(self.config['output_path'])
        self.config['image_path'] = path.join(self.config['project_path'], 'image')
        EvaluationUtilities.check_or_make_path(self.config['image_path'])
        return self.config

    # This function simply returns the image path (where the vm disk images to be processed live)
    def get_image_path(self, error_string='No configuration file specified. Use process_config before proceeding.'):
        if not self.config:
            raise AttributeError(error_string)
        return self.config['image_path']

    # This function returns the list of virus scanners listed in the config file
    def get_virus_scanners(self, error_string='No configuration file specified. Use process_config before proceeding.'):
        if not self.config:
            raise AttributeError(error_string)
        return self.config['virus_scanners']

    # Parses input, looking for -c (--config) /path/to/config_file.txt or -l (--logging) [verbose OR module OR full]
    # to accept user-input config file and logging options. Full = module and main, verbose = main, and module = module
    @staticmethod
    def parse_config_file():
        parser = argparse.ArgumentParser(description='Parse and analyze Noriben output and test virus scanners. See'
                                                     'README.md for more details.')
        parser.add_argument('-c', '--config', type=str, nargs='?',
                            help='Path to configuration file. The program assumes the config is located'
                                 ' at ./config.txt if no configuration file is specified.')
        parser.add_argument('-l', '--logging', type=str, nargs='?', choices=('verbose', 'module', 'full'),
                            help='Options: verbose, module, full. The type of logging desired. Default is to output to '
                                 'STDOUT. "verbose" will log only high level operations, "module-level" will only log '
                                 'module output, and "full" provides both high-level and module-level logging.')
        parser.add_argument('-e', '--external', type=str, nargs='?', choices=('malice', 'virus_total', 'both'),
                            help='Options: malice, virus_total, both. The external multi-scanners (malice and'
                                 'virustotal) used to scan any artifacts recovered from the infected VM.')
        return parser.parse_args()

    @staticmethod
    def process_arguments(arguments):
        if arguments.logging:
            if arguments.logging == 'full':
                logging_option = EvaluationUtilities.MODULE_LOGGING | EvaluationUtilities.MAIN_LOGGING
            elif arguments.logging == 'verbose':
                logging_option = EvaluationUtilities.MAIN_LOGGING
            elif arguments.logging == 'module':
                logging_option = EvaluationUtilities.MODULE_LOGGING
        else:
            logging_option = EvaluationUtilities.NO_LOGGING
        if arguments.external:
            if arguments.external == 'both':
                external_option = ew.ExternalTesting.VIRUSTOTAL | ew.ExternalTesting.MALICE
            elif arguments.external == 'virus_total':
                external_option = ew.ExternalTesting.VIRUSTOTAL
            elif arguments.external == 'malice':
                external_option = ew.ExternalTesting.MALICE
        else:
            external_option = ew.ExternalTesting.NONE
        if arguments.config:
            config_file = arguments.config
        else:
            config_file = "config.txt"
        return config_file, logging_option, external_option

    # Checks to see if Noriben file has been ingested, otherwise raise AttributeError
    def config_check(self, error_string='No Noriben file has been ingested. Call ingest_noriben_data before'
                                        'proceeding'):
        if not self.config:
            raise AttributeError(error_string)

    # Check to see if we know the name of the malware, otherwise raise AttributeError
    def exe_check(self, error_string='No virus has been associated with the file. Use ingest_noriben_csv before'
                                     'proceeding'):
        if not self.exe_file:
            raise AttributeError(error_string)

    # Sets the external scanners used to build some sort of a priori knowledge about the files recovered from the
    # virtual machine. This needs to occur before the logs are set for proper operation of the program
    def set_multiscanners(self, external_scanners):
        self.ew_object.set_external_scanners(external_scanners)
        if external_scanners and ew.ExternalTesting.VIRUSTOTAL:
            self.ew_object.set_virus_total_key(self.config['virustotal_key'])

    # Check to see if we have created a external_wrapper. Creates an external_wrapper object and returns false if none
    # exists, otherwise returns True and does nothing.
    def check_or_create_external_wrapper(self, output_dir, external_wrapper):
        if not self.ew_object:
            self.ew_object = ew.ExternalTesting()
            self.set_multiscanners(external_wrapper)
            if self.module_logging:
                if not output_dir:
                    raise AttributeError("Logging specified, but no reference directory (for output) provided")
                self.ew_object.set_logfile(path.join(self.config['log_path'],
                                                     '{}__external__{}.log'.format(self.time_string, self.exe_file)))
                self.ew_object.set_output_directory(output_dir)
            return False
        else:
            return True

    # Check to see if we have created a forensic_wrapper. Creates a forensic_wrapper object and returns false if none
    # exists, otherwise returns True and does nothing.
    def check_or_create_forensic_wrapper(self, image_file=""):
        if not self.fw_object:
            self.fw_object = fw.ForensicUtility()
            if self.module_logging:
                self.fw_object.set_logfile(path.join(self.config['log_path'],
                                                     '{}__forensic__{}.log'.format(self.time_string,
                                                                                   path.basename(image_file))))
            return False
        else:
            return True

    # Check to see if we have created a virus_scanner_wrapper. Creates a virus_scanner_wrapper object and returns false
    # if none exists, otherwise returns True and does nothing.
    def check_or_configure_virus_scanner_wrapper(self, tool):
        if not self.vs_object:
            self.vs_object = vs.VirusScannerTesting()
        else:
            self.vs_object.close_logfile()
            self.vs_object.close_output()
        if self.module_logging:
            if not self.exe_file:
                virus_output_path = path.join(self.config['output_path'], self.base_name + "_" + self.time_string)
                EvaluationUtilities.check_or_make_path(virus_output_path)
                virus_output_path = path.join(virus_output_path, 'Tools')
            else:
                virus_output_path = path.join(self.config['output_path'], self.exe_file + "_" + self.time_string,
                                              'Tools')
                EvaluationUtilities.check_or_make_path(virus_output_path)
            EvaluationUtilities.check_or_make_path(virus_output_path)
            self.vs_object.set_logfile(path.join(self.config['log_path'],
                                                 '{}__{}__{}.log'.format(self.time_string, tool, self.exe_file)))
            self.vs_object.set_output(path.join(virus_output_path, '{}__{}'.format(self.exe_file, tool) + '.log'))

    # This function uses udisksctl to automagically detect the underlying partition structure of the vm disk
    # and to map the disk image to loop back. The function then mounts partition 2 (the C:\ drive of the vm disk)
    # and returns the path of the mounted disk image. This function operates in userspace and does not require root
    def safemount_image(self, image_file):
        self.config_check('You must process the configuration file with process_config before attempting to mount '
                          'the VM image')
        self.check_or_create_forensic_wrapper(image_file)
        self.logfile.write('Attempting to mount {}\n'.format(image_file))
        self.loop_device, self.mount_path = self.fw_object.safemount_image(image_file)
        self.base_name = path.basename(image_file)
        if self.mount_path:
            self.noriben_path = self.windows_path_to_local_path(self.config['remote_path'])
            self.logfile.write('Successfully mounted {} as {}\n'.format(image_file, self.mount_path))
            return True
        elif self.loop_device:
            self.fw_object.delete_loop(self.loop_device)
            raise IOError('Failed to mount {} from loop device \n'.format(image_file))
        else:
            raise IOError('Failed to setup loop device from {} \n'.format(image_file))
            
    # This function unmounts the loopback device, then deletes the loopback device.
    def unmount_image(self):
        self.logfile.write('Attempting to unmount and remove block device associated with {}\n'.format(self.mount_path))
        if not self.loop_device:
            raise AttributeError('No loopback device to unmount/delete')
        self.fw_object.unmount_image(self.loop_device)
        self.fw_object.delete_loop(self.loop_device)
        self.mount_path = ''
        self.loop_device = ''
        return False

    # This function finds the Noriben timeline CSV stored in the noriben_path and ingests the File and Registry entries,
    # which are stored as a list of lists in files and registry_entries respectively. Catches a IO error raised if the
    # file is not found or opened. Because we don't know what virus was executed before running this module, we use a
    # temporary logfile if module_logging is enabled. This module also copies the Noriben Timeline to "output_path"
    def ingest_noriben_data(self):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        try:
            self.files, self.registry_entries, self.full_exe_file, timeline_path = self.fw_object.ingest_noriben_data(
                self.noriben_path)
        except IOError:
            return False
        self.exe_file = path.splitext(self.full_exe_file)[0]
        output_dir = path.join(self.config['output_path'], self.exe_file + "_" + self.time_string)
        self.check_or_make_path(output_dir)
        output_timeline_path = path.join(output_dir, "Timeline")
        self.check_or_make_path(output_timeline_path)
        copy(timeline_path, path.join(output_timeline_path, path.basename(timeline_path)))
        malware_full_path = path.join(self.noriben_path, 'Malware', self.full_exe_file)
        if path.isfile(malware_full_path):
            output_files_path = path.join(output_dir, "Files")
            self.check_or_make_path(output_files_path)
            copy(malware_full_path, output_files_path)
        if self.exe_file:
            return True
        else:
            return False

    # Since we are looking at a timeline, we are trying to find the last entry to find (we don't care if the same)
    # entry was overwritten or was deleted and recreated, we just want to know where the file *should* exist in the
    # file structure or not.
    def classify_files_from_noriben_csv(self):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.classify_files_from_noriben_csv(self.files)

    # Since we are looking at a timeline, we are trying to find the last entry to find (we don't care if the same)
    # entry was overwritten or was deleted and recreated, we just want to know where the file *should* exist in the
    # file structure or not.
    def classify_registry_entries_from_noriben_csv(self):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.classify_registry_entries_from_noriben_csv(self.registry_entries)

    # Simple function that checks for a path. If it exists, it does nothing, otherwise it creates the path.
    @staticmethod
    def check_or_make_path(target_path):
        if not path.isdir(target_path):
            mkdir(target_path)

    # This generates a list of filenames (artifact + "_" + md5), md5 sums, and paths for all the files dumped into the
    # Files directory during the process_files action. This list can be used to invoke the external_wrapper scanners
    def process_file_list_md5(self, output_dir, files_dir):
        md5_dir = path.join(output_dir, "MD5")
        EvaluationUtilities.check_or_make_path(md5_dir)
        md5sum_output = run('find {}/ -maxdepth 1 -type f -exec md5sum {{}} \\;'.format(files_dir), shell=True,
                            encoding='utf-8', stdout=PIPE)
        with open(path.join(md5_dir, self.exe_file + '_md5.txt'), 'w') as write_file:
            write_file.write(md5sum_output.stdout)
        md5_list = []
        for item in md5sum_output.stdout.splitlines():
            md5_sum, file_path = item.split()
            md5_list.append(['{}_{}'.format(path.basename(file_path), md5_sum), md5_sum, file_path])
        return md5_list

    # This simply makes a log of all the file-related entries in the Noriben timeline .csv
    def write_processed_files_reference(self, process_dir, output_log_list):
        EvaluationUtilities.check_or_make_path(process_dir)
        process_log = path.join(process_dir, '{}.files_reference.log'.format(self.exe_file))
        with open(process_log, 'w') as process_log_file:
            for entry in output_log_list:
                for value in entry:
                    process_log_file.write('{},'.format(value))
                process_log_file.write('\n')

    # This simply makes a log of the deleted file-related entries in the Noriben timeline .csv. Future development
    # of the project could use this data to see how forensic malware protocols handle deleted files.
    def write_processed_files_deleted(self, process_dir, deleted_list):
        EvaluationUtilities.check_or_make_path(process_dir)
        process_log = path.join(process_dir, '{}.files_deleted.log'.format(self.exe_file))
        with open(process_log, 'w') as process_log_file:
            processed_files = self.translate_windows_special_directories(deleted_list)
            for i in range(len(deleted_list)):
                local_path = self.windows_path_to_local_path(processed_files[i])
                process_log_file.write("{},{},\n".format(deleted_list[i][3], local_path))

    # This function takes the md5_list ([filename, md5, filepath]) and supplies it to the external scanners (currently
    # VirusTotal and Malice)
    def process_file_list_multiscanner(self, md5_list, output_dir, external_scanners):
        self.check_or_create_external_wrapper(output_dir, external_scanners)
        self.set_multiscanners(external_scanners)
        self.ew_object.process_file_list_multiscanner(md5_list)

    # This function does two main things: first, it parses a list of noriben entries (either file list or self.file list
    # into local paths and tries to copy those files. Then, the function saves a log of what it could and could not find
    # in csv format. If deleted_list is supplied, a log is made of those files, too. I have also added functionality
    # that obtains and outputs the MD5 sum of each file and sends the files to the external multiscanners (currently
    # VirusTotal and Malice). In this manner, the person using the tool has a fair body of automatically generated
    # evidence describing a recovered file. Some of the other Malice information might be suitable for integration as
    # well
    def process_file_list(self, file_list=None, deleted_list=None,
                          external_scanners=ew.ExternalTesting.VIRUSTOTAL | ew.ExternalTesting.MALICE):
        self.config_check()
        self.exe_check()
        self.check_or_create_forensic_wrapper()
        output_dir = path.join(self.config['output_path'], self.exe_file + '_' + self.time_string)
        output_log_list = []
        if file_list:
            compare_list = file_list
        else:
            compare_list = self.files
        processed_files = self.translate_windows_special_directories(compare_list)
        EvaluationUtilities.check_or_make_path(output_dir)
        files_dir = path.join(output_dir, "Files")
        EvaluationUtilities.check_or_make_path(files_dir)
        for i in range(len(processed_files)):
            local_path = self.windows_path_to_local_path(processed_files[i])
            try:
                if path.isfile(local_path):
                    output_path = path.join(files_dir, path.basename(local_path))
                    if path.isfile(output_path):
                        time_string = datetime.now().strftime('%Y%m%d_%H%M%S_%f')
                        output_path = path.join(output_path, time_string)
                    if self.fw_object.copy_and_verify_file(local_path, output_path):
                        output_log_list.append([compare_list[i][3], local_path, 'Y'])
                else:
                    output_log_list.append([compare_list[i][3], local_path, 'N'])
            except IOError:
                print('Could not open {}'.format(local_path))
        process_dir = path.join(files_dir, "Logs")
        self.write_processed_files_reference(process_dir, output_log_list)
        self.write_processed_files_deleted(process_dir, deleted_list)
        md5_list = self.process_file_list_md5(output_dir, files_dir)
        self.process_file_list_multiscanner(md5_list, output_dir, external_scanners)

    # This function does two main things: first, it parses a list of noriben entries (either file list or self.file list
    # into local paths and tries to copy those files. Then, the function saves a log of what it could and could not find
    # in csv format. If deleted_list is supplied, a log is made of those files, too. This function is much like
    # process_file_list, but it is geared toward registry entries.
    def process_registry_list(self, registry_entries_list, deleted_entries_list):
        self.config_check()
        self.exe_check()
        self.check_or_create_forensic_wrapper()
        output_dir = path.join(self.config['output_path'], self.exe_file + '_' + self.time_string)
        if registry_entries_list:
            compare_list = registry_entries_list
        else:
            compare_list = self.registry_entries
        EvaluationUtilities.check_or_make_path(output_dir)
        output_dir = path.join(output_dir, "Registry")
        EvaluationUtilities.check_or_make_path(output_dir)
        entry_list = []
        found_list = []
        for entry in compare_list:
            try:
                registry_file, registry_entry = self.registry_association(entry[5])
                key, separator, subkey = registry_entry.rpartition("\\")
                value = self.get_registry_entry(registry_file, key, subkey)
                if value:
                    found_list.append([registry_file, registry_entry, value])
                    entry_list.append([registry_file, registry_entry, 'Y', value])
                else:
                    entry_list.append([registry_file, registry_entry, 'N', ''])
            except Exception as e:
                print(entry)
                raise e
        values_path = path.join(output_dir, "{}_created_registry_values.log".format(self.exe_file))
        if found_list:
            with open(values_path, 'w') as output_file:
                for entry in found_list:
                    for value in entry:
                        output_file.write('{},'.format(value))
                    output_file.write('\n')
        process_dir = path.join(output_dir, "Logs")
        process_log = path.join(process_dir, '{}.created_registry_entries.log'.format(self.exe_file))
        EvaluationUtilities.check_or_make_path(process_dir)
        with open(process_log, 'w') as process_log_file:
            for entry in entry_list:
                for value in entry:
                    process_log_file.write('{},'.format(value))
                process_log_file.write('\n')
        if deleted_entries_list:
            process_log = path.join(process_dir, '{}.deleted_registry_entries.log'.format(self.exe_file))
            with open(process_log, 'w') as process_log_file:
                for i in range(len(deleted_entries_list)):
                    registry_file, registry_entry = self.registry_association(deleted_entries_list[i][5])
                    process_log_file.write("{},{},\n".format(registry_file, registry_entry))

    # This function prunes the drive designation (C:\) and any leading forward slashes from a path, then converts
    # the path to a path traversable on the local machine, using the mount point as the root
    def windows_path_to_local_path(self, file_path):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.windows_path_to_local_path(self.mount_path, file_path)

    # This function maps registry key entries to the mounted vm drive. No logging currently implemented (low value,
    # verbosity)
    def registry_association(self, key):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.get_registry_association(self.mount_path, key)

    # This function maps registry key entries to the mounted vm drive. No logging currently implemented (low value,
    # verbosity)
    def get_registry_entry(self, registry_path, key, subkey):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        return self.fw_object.get_registry_entry(registry_path, key, subkey)

    # This function Windows path variables (%APPDATA%) to paths
    def translate_windows_special_directories(self, file_list=None):
        self.config_check()
        self.check_or_create_forensic_wrapper()
        if file_list:
            processed_output = self.fw_object.translate_windows_special_directories(file_list, self.config)
        else:
            processed_output = self.fw_object.translate_windows_special_directories(self.files, self.config)
        return processed_output

    # This function attempts to execute the specified tool on the <target_path>. Otherwise, we will use self.mount_path
    # as the target.
    def execute_tool(self, tool, target_path=None):
        self.config_check()
        if target_path:
            tool_path = target_path
        else:
            tool_path = self.mount_path
        self.check_or_configure_virus_scanner_wrapper(tool)
        self.logfile.write('Invoking {} on {}.\n'.format(tool, tool_path))
        tool_id = self.vs_object.get_tool_id(tool)
        if self.vs_object.execute_tool_test(tool_id, tool_path):
            return True
        else:
            return False

    # Execute all the listed scanners in the config file on the <target_path>. Otherwise, we will use self.mount_path
    # as the target (see execute_tool)
    def execute_virus_scanners(self, target_path=None):
        for virus_scanner in self.config['virus_scanners'].split(','):
            self.execute_tool(virus_scanner, target_path)

    # Close any modules and the logpath. Unmount any drives.
    def close(self):
        if self.mount_path:
            self.fw_object.unmount_image(self.loop_device)
        if self.loop_device:
            self.fw_object.delete_loop(self.loop_device)
        if self.logfile != stdout:
            self.logfile.close()
        if self.fw_object:
            self.fw_object.close()
        if self.vs_object:
            self.vs_object.close()

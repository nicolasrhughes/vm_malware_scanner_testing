import os
import virtualbox
from sys import stdout
from time import sleep


class VMNotFoundException(Exception):
    pass


class VMManagerNotFoundException(Exception):
    pass


class VMManage:
    VIRTUALBOX = 0

    """ This version minimizes the amount of parameters to """

    def __init__(self):
        self.vm_disk_path = ""
        self.vm_name = ""
        self.vm_manager_path = ""
        self.vm_timeout = 360
        self.vm_manager = -1
        self.vm_instance = None
        self.vm_wrapper = None
        self.vm_storage_controller = None
        self.vm_session = None
        self.vm_original_medium = None
        self.vm_opened_medium = None
        self.logfile = stdout

    """ Public functions """

    """ Two separate ways to find the VM - either using the machine's name or by finding the virtual machine's
        virtual disk """

    def set_logfile_by_directory(self, logfile_directory):
        self.logfile = open(os.path.join(logfile_directory, "vbox_wrapper.log"), "w")

    def set_logfile(self, logfile_path):
        self.logfile = open(logfile_path, "w")

    def check_if_vm_manager_implemented(self):
        if self.vm_manager == VMManage.VIRTUALBOX:
            return True
        else:
            return False

    def find_vm_name_from_path(self):
        self.logfile.write("\tLooking for virtual machine with drive path {}\n".format(self.vm_disk_path))
        machines = self.vm_wrapper.machines
        for machine in machines:
            for attachment in machine.medium_attachments:
                try:
                    if attachment.medium.location == self.vm_disk_path:
                        if self.vm_storage_controller:
                            self.logfile.write("\t\tWarning: disk {} found attached to multiple virtual machines {}"
                                               "\n".format(self.vm_disk_path, machine.name))
                        else:
                            self.vm_name = machine.name
                            self.vm_original_medium = attachment.medium
                            self.vm_storage_controller = attachment.controller
                except AttributeError:
                    pass

        if self.vm_name:
            self.logfile.write("\t\tStorage media with path {} found attached to virtual machine "
                               "{}\n".format(self.vm_disk_path, self.vm_name))
            return True
        else:
            self.logfile.write("\t\tPath {} was not found to be attached to any virtual machine."
                               "\n".format(self.vm_disk_path, self.vm_name))
            return False

    def find_vm_disk_path_from_name(self):
        self.logfile.write("\tLooking for virtual disk path for virtual machine {}.\n".format(self.vm_name))
        if self.vm_manager == VMManage.VIRTUALBOX:
            attachments = self.vm_instance.medium_attachments
            if len(attachments) > 1:
                self.logfile.write("\t\tWarning: multiple disks found attached to virtual machine {}. Assigning vm_name"
                                   "based on first attachment.\n".format(self.vm_name))
                for attachment in attachments:
                    self.logfile.write("\t\tWarning: disk {} found attached to virtual machine {}"
                                       "\n".format(self.vm_name, attachment.medium.location))
            elif len(attachments) == 0:
                self.logfile.write("\t\tNo storage media found attached to virtual machine {}\n".format(self.vm_name))
                return False
            self.vm_disk_path = attachments[0].medium.location
            self.vm_original_medium = attachments[0].medium
            self.vm_storage_controller = attachments[0].controller
        if self.vm_disk_path:
            self.logfile.write("\t\tStorage media with path {} found attached to virtual machine "
                               "{}\n".format(self.vm_disk_path, self.vm_name))
            return True
        else:
            self.logfile.write("\t\tVirtual machine {} has no attachments.\n".format(self.vm_name, self.vm_name))
            return False

    def configure_controller_from_name_and_path(self):
        for attachment in self.vm_instance.medium_attachments:
            if attachment.medium.location == self.vm_disk_path:
                if self.vm_storage_controller:
                    self.logfile.write("\t\tWarning: disk {} found attached to multiple virtual machines {}"
                                       "\n".format(self.vm_disk_path, attachment.medium.name))
                else:
                    self.vm_storage_controller = attachment.controller
                    self.vm_original_medium = attachment.medium

    def set_vm(self, vm_name_string="", vm_disk_path_string="", vm_manager_value=VIRTUALBOX,
               vm_timeout_value=360):
        if (not vm_name_string) and (not vm_disk_path_string):
            self.logfile.write("Unable to initialize without the virtual machine name and/or the disk path.\n")
            raise ValueError("Unable to initialize without the virtual machine name and/or the disk path.\n")
        self.logfile.write("Attempting to initialize virtual machine by virtual machine name and path.\n")
        self.vm_disk_path = vm_disk_path_string
        self.vm_manager = vm_manager_value
        self.vm_timeout = vm_timeout_value
        if not self.check_if_vm_manager_implemented():
            self.logfile.write("\tVirtual Machine manger specified currently unimplemented.\n")
            raise ValueError("\tThe virtual machine mananager specified is not currently "
                             "supported {}.\n".format(self.vm_manager))
        if self.vm_manager == VMManage.VIRTUALBOX:
            self.vm_wrapper = virtualbox.VirtualBox()
            self.vm_session = virtualbox.Session()
        if vm_name_string:
            self.vm_name = vm_name_string
            self.vm_instance = self.vm_wrapper.find_machine(self.vm_name)
            if not self.vm_instance:
                self.logfile.write("\tFailed to find virtual machine {}\n".format(self.vm_name))
                raise ValueError("\tFailed to find virtual machine {}\n".format(self.vm_name))
            if vm_disk_path_string:
                self.vm_disk_path = vm_disk_path_string
                self.configure_controller_from_name_and_path()
            elif not self.find_vm_disk_path_from_name():
                self.logfile.write("\tFailed to find virtual disk associated with virtual machine "
                                   "{}\n".format(self.vm_name))
                raise virtualbox.library.VBoxErrorVmError("\tNo storage media found attached to virtual machine")
        else:
            if not self.find_vm_name_from_path():
                self.logfile.write("Failed to find virtual machine with drive path {}\n".format(self.vm_disk_path))
                return False
            else:
                self.vm_instance = self.vm_wrapper.find_machine(self.vm_name)
        if self.vm_wrapper and self.vm_instance:
            self.logfile.write("\tSuccessfully initialized virtual machine by name and path.\n")
            return True
        else:
            self.logfile.write("\tFailed to successfully initialize virtual machine by name and path.\n")
            return False

    """ Start the virtual machine and check to see if output indicates machine started """

    def start_vm(self):
        self.logfile.write("Attempting to start virtual machine {}.\n".format(self.vm_name))
        progress = self.vm_instance.launch_vm_process(type_p="headless")
        if progress:
            progress.wait_for_completion(self.vm_timeout)
            if self.vm_instance.state == virtualbox.library.MachineState.running:
                self.logfile.write("\tSuccessfully initialized virtual machine {}.\n".format(self.vm_name))
                self.vm_session = self.vm_instance.create_session()
                return True
        self.logfile.write("\tFailed to start virtual machine {}.\n".format(self.vm_name))
        return False

    def open_drive(self, drive_path_string):
        self.logfile.write("Attempting to open virtual machine disk {}.\n".format(drive_path_string))
        self.vm_opened_medium = self.vm_wrapper.open_medium(drive_path_string,
                                                            virtualbox.library.DeviceType.hard_disk,
                                                            virtualbox.library.AccessMode.read_write,
                                                            force_new_uuid=False)
        if self.vm_opened_medium:
            self.logfile.write("\tSuccessfully opened virtual machine disk {}.\n".format(drive_path_string))
            return True
        else:
            self.logfile.write("\tFailed to open virtual machine disk {}.\n".format(drive_path_string))
            return False

    def reattach_original_medium(self):
        self.logfile.write("Attempting to re-attach original drive {} to virtual "
                           "machine {}.\n".format(self.vm_original_medium.location, self.vm_name))
        if self.vm_original_medium:
            self.vm_instance.lock_machine(self.vm_session, virtualbox.library.LockType.write)
            mutable_machine = self.vm_session.machine
            mutable_machine.detach_device(self.vm_storage_controller, 0, 0)
            mutable_machine.attach_device("SATA", 0, 0, virtualbox.library.DeviceType.hard_disk,
                                          self.vm_original_medium)
            mutable_machine.save_settings()
            self.vm_session.unlock_machine()
            self.logfile.write("\tSuccessfully re-attached original drive {} to virtual "
                               "machine {}.\n".format(self.vm_original_medium.location, self.vm_name))
            return True
        else:
            self.logfile.write("\tFailed to re-attach original drive {} virtual machine "
                               "{}.\n".format(self.vm_original_medium.location, self.vm_name))
            return False

    def attach_opened_medium(self):
        self.logfile.write("Attempting to attach opened drive drive {} to virtual"
                           "machine {}.\n".format(self.vm_opened_medium.location, self.vm_name))
        if self.vm_opened_medium:
            self.vm_instance.lock_machine(self.vm_session, virtualbox.library.LockType.write)
            mutable_machine = self.vm_session.machine
            mutable_machine.detach_device(self.vm_storage_controller, 0, 0)
            mutable_machine.save_settings()
            mutable_machine.attach_device(self.vm_storage_controller, 0, 0, virtualbox.library.DeviceType.hard_disk,
                                          self.vm_opened_medium)
            mutable_machine.save_settings()
            self.vm_session.unlock_machine()
            self.logfile.write("\tAttached opened drive {} to virtual machine "
                               "{}.\n".format(self.vm_opened_medium.location, self.vm_name))
            return True
        else:
            self.logfile.write("Failed to attach opened drive {} virtual machine "
                               "{}.\n".format(self.vm_opened_medium.location, self.vm_name))
            return False

    def print_attachments(self):
        my_location = None
        my_controller = None
        if self.vm_manager == VMManage.VIRTUALBOX:
            attachments = self.vm_instance.medium_attachments
            for attachment in attachments:
                try:
                    if attachment.medium:
                        my_location = attachment.medium.location
                    if attachment.controller:
                        my_controller = attachment.controller
                    self.logfile.write("Controller: {} Location: {}\n".format(my_controller, my_location))
                except AttributeError:
                    pass

    def obtain_vm_ip(self):
        self.logfile.write("Attempting to obtain IP address for virtual machine {}.\n".format(self.vm_name))
        for i in range(self.vm_timeout):
            result = self.vm_instance.enumerate_guest_properties('/VirtualBox/GuestInfo/Net/0/V4/IP')
            try:
                ip_address_string = result[1][0]
                if ip_address_string:
                    if ip_address_string[0:3] != "169":
                        self.logfile.write("\tIP address {} obtained for virtual machine "
                                           "{}.\n".format(ip_address_string, self.vm_name))
                        return ip_address_string
                sleep(.1)
            except IndexError:
                sleep(.1)
        return ""

    def check_vm_shutdown(self):
        self.logfile.write("Checking to see if virtual machine {} has been powered off.\n".format(self.vm_name))
        if self.vm_instance.state == virtualbox.library.MachineState.powered_off:
            self.logfile.write("\tVirtual machine {} was successfully powered off.\n".format(self.vm_name))
            return True
        self.logfile.write("\tProcess timed out before {} indicated that it was powered off.\n".format(self.vm_name))
        return False

    def wait_for_vm_unlock(self):
        for i in range(0, self.vm_timeout):
            if self.vm_session.state == virtualbox.library.SessionState.locked:
                self.logfile.write("\tVirtual machine {} was successfully powered off.\n".format(self.vm_name))
                return True
            sleep(.1)
        self.logfile.write("\tProcess timed out before {} indicated that it was powered off.\n".format(self.vm_name))
        return False

    def vm_pause(self):
        self.logfile.write("Attempting to pause virtual machine {}.\n".format(self.vm_name))
        self.vm_session.console.pause()
        for i in range(0, self.vm_timeout):
            if self.vm_instance.state == virtualbox.library.MachineState.paused:
                self.logfile.write("\tSuccessfully paused virtual machine {}.\n".format(self.vm_name))
                return True
            sleep(.1)
        self.logfile.write("\tFailed to pause virtual machine {}.\n".format(self.vm_name))
        return False

    def vm_resume(self):
        self.logfile.write("Attempting to resume virtual machine {}.\n".format(self.vm_name))
        self.vm_session.console.resume()
        for i in range(0, self.vm_timeout):
            if self.vm_instance.state == virtualbox.library.MachineState.running:
                self.logfile.write("\tSuccessfully resumed virtual machine {}.\n".format(self.vm_name))
                return True
            sleep(.1)
        self.logfile.write("\tFailed to resume virtual machine {}.\n".format(self.vm_name))
        return False

    def vm_shutdown(self):
        self.logfile.write("Attempting to shut down virtual machine {}.\n".format(self.vm_name))
        progress = self.vm_session.console.power_down()
        if progress:
            progress.wait_for_completion(self.vm_timeout)
            if self.vm_instance.state == virtualbox.library.MachineState.powered_off:
                self.logfile.write("\tSuccessfully shut down virtual machine {}.\n".format(self.vm_name))
                sleep(.1)
                return True
        self.logfile.write("\tFailed to shut down virtual machine {}.\n".format(self.vm_name))
        return False

    def close(self):
        self.vm_disk_path = None
        self.vm_name = None
        self.vm_manager_path = None
        self.vm_timeout = None
        self.vm_manager = None
        self.vm_instance = None
        self.vm_wrapper = None
        self.vm_storage_controller = None
        self.vm_session = None
        self.vm_original_medium = None
        self.vm_opened_medium = None
        if self.logfile != stdout:
            self.logfile.close()
        self.vm_session = None

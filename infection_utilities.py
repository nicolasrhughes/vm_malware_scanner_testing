import vbox_wrapper as vm
import forensic_wrapper as fw
import ssh_sftp_wrapper as ssh
from os import path
from os import mkdir
import ntpath
import posixpath
from sys import stdout
from time import sleep
from datetime import datetime


class InfectionUtilities:

    MODULE_LOGGING = 4
    MAIN_LOGGING = 2
    NO_LOGGING = 0

    def __init__(self):
        self.config = {}
        self.module_logging = False
        self.logfile = stdout
        self.virus_name = ''
        self.vm_object = None
        self.vm_log = None
        self.fw_object = None
        self.fw_log = None
        self.ssh_object = None
        self.ssh_log = None
        self.vs_log = None
        self.vm_hash = ''
        self.time_string = datetime.now().strftime('%Y-%m-%d_%H%M%S')
        self.working_filename = ''
        self.working_path = ''
        self.revert_drive_attachment_required = False
        self.ip_address = ''
        self.full_launcher_path = ''

    def process_config(self, filename):
        self.config = {}
        with open(filename) as config_file:
            for line in config_file:
                variable, value = line.strip().split(': ', 1)
                self.config[variable] = value
        if not path.isdir(self.config['project_path']):
            mkdir(self.config['project_path'])
        self.config['vm_path'] = path.join(self.config['project_path'], 'base', 'base.raw')
        self.config['log_path'] = path.join(self.config['project_path'], 'log')
        if not path.isdir(self.config['log_path']):
            mkdir(self.config['log_path'])
        self.config['reference_path'] = path.join(self.config['project_path'], 'reference')
        self.config['log_path'] = path.join(self.config['project_path'], 'log')
        InfectionUtilities.check_or_make_path(self.config['log_path'])
        self.config['reference_path'] = path.join(self.config['project_path'], 'reference')
        InfectionUtilities.check_or_make_path(self.config['reference_path'])
        self.config['output_path'] = path.join(self.config['project_path'], 'output')
        InfectionUtilities.check_or_make_path(self.config['output_path'])
        self.config['image_path'] = path.join(self.config['project_path'], 'image')
        InfectionUtilities.check_or_make_path(self.config['image_path'])
        self.config['launcher_path'] = path.join(self.config['project_path'], 'utilities')
        InfectionUtilities.check_or_make_path(self.config['launcher_path'])
        self.config['remote_port'] = int(self.config['remote_port'])
        self.config['timeout_seconds'] = int(self.config['timeout_seconds'])
        self.config['block_size'] = int(self.config['block_size'])
        self.config['mount_offset'] = str(int(self.config['mount_offset']) * self.config['block_size'])
        self.config['compare_offset'] = int(self.config['compare_offset']) * self.config['block_size']
        self.config['boot_delay'] = int(self.config['boot_delay'])
        self.config['ip_delay'] = int(self.config['ip_delay'])
        self.config['infect_delay'] = int(self.config['ip_delay'])
        self.config['shutdown_delay'] = int(self.config['shutdown_delay'])
        return self.config

    @staticmethod
    def check_or_make_path(target_path):
        if not path.isdir(target_path):
            mkdir(target_path)

    def config_check(self, error_string='No configuration file specified. Use process_config before proceeding.'):
        if not self.config:
            raise AttributeError(error_string)

    def vm_check(self, error_string='No VM attached. Use attach_vm before proceeding.'):
        if not self.vm_object:
            raise AttributeError(error_string)

    def fw_check(self, error_string='Forensic wrapper not initialized. Use please use a method that creates a fw'
                                    'object before proceeding.'):
        if not self.fw_object:
            raise AttributeError(error_string)

    def cloned_check(self, error_string='No cloned VM disk detected. Use clone_vm_disk before proceeding.'):
        if not self.working_filename or not self.working_path:
            raise AttributeError(error_string)

    def ip_check(self, error_string='No VM IP address reported. Use start_vm and ensure VM network is configured'
                                    'appropiately before proceeding.'):
        if not self.ip_address:
            raise AttributeError(error_string)

    def ssh_check(self, error_string='No SSH session reported. Use start_vm_ssh_session before proceeding.'):
        if not self.ip_address:
            raise AttributeError(error_string)

    def set_logging(self, logging_type):
        if not self.config:
            raise AttributeError('Logging requested before specifying log configuration')
        if (logging_type and self.MAIN_LOGGING) == self.MAIN_LOGGING:
            self.logfile = open(path.join(self.config['log_path'], self.virus_name + "_" + self.time_string +
                                          '__main__' + '.log'), 'w')
        if (logging_type and self.MODULE_LOGGING) == self.MODULE_LOGGING:
            self.module_logging = True

    def get_virus_path(self):
        self.config_check('Please specify configuration with process_config before attempting to return paths')
        return self.config['virus_path']

    def get_full_launcher_path(self):
        if not self.full_launcher_path:
            raise AttributeError('Please call create_windows_launcher before proceeding')
        return self.full_launcher_path

    def set_virus_name(self, virus):
        self.virus_name = virus

    # The following functions primarily involve virtualbox commands sent through our virtualbox wrapper for the python
    # virtualbox module
    def attach_vm(self):
        self.config_check('Please specify configuration with process_config before attempting to attach a vm')
        self.logfile.write('Starting virtual machine module.\n')
        self.vm_object = vm.VMManage()
        if self.module_logging:
            self.vm_object.set_logfile(path.join(self.config['log_path'], self.virus_name + "_" + self.time_string +
                                                 '__vm__' + '.log'))
        self.logfile.write('Setting logfile.\n')
        self.logfile.write('Setting VM from path {}.\n'.format(self.config['vm_path']))
        self.vm_object.set_vm(vm_disk_path_string=self.config['vm_path'], vm_manager_value=vm.VMManage.VIRTUALBOX,
                              vm_timeout_value=self.config['timeout_seconds'])
        if self.vm_object:
            return True

    def attach_cloned_drive(self):
        self.config_check('Please specify configuration with process_config before attaching a cloned disk')
        self.vm_check('Please attach a vm with attach_vm before cloning its disk')
        self.cloned_check('Please clone VM using clone_vm_disk before trying to attach the cloned disk to the vm')
        # Attach clone drive to target virtual machine
        self.logfile.write('Opening cloned drive.\n')
        self.vm_object.print_attachments()
        self.vm_object.open_drive(self.working_path)
        self.logfile.write('Attaching cloned drive.\n')
        success = self.vm_object.attach_opened_medium()
        self.vm_object.print_attachments()
        self.revert_drive_attachment_required = True
        return success

    def revert_drive_attachment(self):
        self.config_check('Please specify configuration with process_config before attaching a cloned disk')
        self.vm_check('Please attach a vm with attach_vm before cloning its disk')
        self.cloned_check('Please clone VM using clone_vm_disk before trying to attach the cloned disk to the vm')
        self.vm_object.wait_for_vm_unlock()
        success = self.vm_object.reattach_original_medium()
        self.vm_object.print_attachments()
        self.revert_drive_attachment_required = False
        return success

    def start_vm(self):
        # Start VM and detect the VM's IP address
        self.config_check('Please specify configuration with process_config before starting a vm')
        self.vm_check('Please attach a vm with attach_vm before cloning its disk')
        self.logfile.write('Starting VM.\n')
        self.vm_object.start_vm()
        sleep(self.config['boot_delay'])
        return True

    def attach_vm_ip(self):
        self.logfile.write('Obtaining IP from VM.\n')
        self.ip_address = self.vm_object.obtain_vm_ip()
        sleep(self.config['ip_delay'])
        return self.ip_address

    def shutdown_vm(self):
        self.config_check('Please specify configuration with process_config before attempting shutdown a VM')
        self.vm_check('Please attach a vm before attempting to shut it down')
        self.logfile.write('\tSending shutdown command to {} through virtualbox API.\n'.format(self.config['vm_name']))
        self.vm_object.vm_shutdown()

    # These functions involve SSH/SFTP commands sent through the Paramiko wrapper

    # This function starts a Paramiko connection, relies on the ssh/sftp wrapper to throw exceptions, and returns
    # True if successful
    def start_vm_ssh_session(self):
        self.config_check('Please specify configuration with process_config before attempting to connect to a vm via'
                          'ssh/sftp')
        self.vm_check('Please attach a vm with attach_vm attempting to connect to the vm via ssh/sftp')
        self.ip_check('Please start the vm with start_vm before attempting to connect via ssh/sftp')
        # Establish SSH connection to VM
        self.logfile.write('\tAttempting to obtain SSH/SFTP connection to {}.\n'.format(self.ip_address))
        self.ssh_object = ssh.SSHManage()
        if self.module_logging:
            self.ssh_object.set_logfile(path.join(self.config['log_path'], self.virus_name + "_" + self.time_string +
                                                  '__ssh__' + '.log'))
        self.ssh_object.configure_connection(self.ip_address, username=self.config['remote_username'],
                                             password=self.config['remote_password'], port=self.config['remote_port'])
        for i in range(0, self.config['timeout_seconds']):
            if self.ssh_object.start_connection():
                return True
            elif i == self.config['timeout_seconds'] - 1:
                self.logfile.write('Failed to establish SSH/SFTP connection - application terminating '
                                   'unsuccessfully.\n')
                raise RuntimeError('Failed to establish SSH/SFTP connection')
            sleep(.1)

    # This function starts a Paramiko SFTP session,relies on the ssh/sftp wrapper to throw exceptions, and returns
    # True if successful
    def start_vm_sftp_session(self):
        self.config_check('Please specify configuration with process_config before attempting to connect to a vm via'
                          'ssh/sftp')
        self.vm_check('Please attach a vm with attach_vm attempting to connect to the vm via ssh/sftp')
        self.ssh_check('Please start an ssh session with the vm using start_vm_ssh_session before attempting to '
                       'send it files via sftp')
        self.logfile.write('Starting SFTP connection with {}'.format(self.ip_address))
        self.ssh_object.start_connection()
        if self.ssh_object.start_sftp():
            return True

    # This function closes a Paramiko SFTP session, relies on the ssh/sftp wrapper to throw exceptions, and returns
    # True if successful
    def close_vm_sftp_session(self):
        self.config_check('Please specify configuration with process_config before attempting to close the sftp '
                          'session')
        self.vm_check('Please attach a vm with attach_vm attempting to close the sftp session')
        if self.ssh_object:
            self.logfile.write('Closing SFTP connection with {}'.format(self.ip_address))
            if self.ssh_object.close_sftp():
                return True

    # This function puts a single directory or file to a remote Paramiko SFTP session and relies on the ssh/sftp
    # wrapper to throw exceptions
    def send_vm_sftp_file_or_dir(self, item_path, remote_subdirectory=''):
        if not remote_subdirectory:
            remote_path = self.config['remote_path']
            remote_ftp_path = self.config['remote_ftp_path']
        else:
            if self.config['remote_type'] == 'windows':
                remote_path = ntpath.join(self.config['remote_path'], remote_subdirectory)
            else:
                remote_path = posixpath.join(self.config['remote_path'], remote_subdirectory)
            remote_ftp_path = posixpath.join(self.config['remote_ftp_path'], remote_subdirectory)
        if path.isdir(item_path):
            self.logfile.write('\tOverwriting remote contents at {} with local contents at {}.'
                               '\n'.format(remote_path, item_path))
            self.ssh_object.delete_recreate_and_put_directory(input_directory=item_path,
                                                              output_ftp_directory=remote_ftp_path,
                                                              output_directory=remote_path,
                                                              os_type=self.config['remote_type'])
        else:
            self.logfile.write('\tPutting local file {} to {}\n'.format(item_path, remote_ftp_path))
            if self.config['remote_type'] == 'windows':
                self.ssh_object.put(input_path=item_path, output_path=ntpath.join(remote_ftp_path,
                                                                                  path.basename(item_path)))
            else:
                self.ssh_object.put(input_path=item_path, output_path=posixpath.join(remote_ftp_path,
                                                                                     path.basename(item_path)))

    def create_windows_launcher(self, item):
        if not self.fw_object:
            self.fw_object = fw.ForensicUtility()
        self.fw_object.create_windows_launcher(self.config['launcher_path'], self.config['remote_path'], item)
        self.full_launcher_path = path.join(self.config['launcher_path'], 'launcher.vbs')

    def setup_startup_link(self):
        self.config_check('Please specify configuration with process_config before attempting to connect to a vm via'
                          'ssh/sftp')
        self.vm_check('Please attach a vm with attach_vm attempting to connect to the vm via ssh/sftp')
        self.ssh_check('Please start an ssh session with the vm using start_vm_ssh_session before attempting to shut '
                       'it down via ssh')
        self.fw_check('Please set the malware path before activating batch file')
        self.logfile.write('\tCreating startup link to vbscript file on {} using SSH.\n'.format(self.ip_address))
        success = False
        if self.config['remote_type'] == 'windows':
            startup_link = ntpath.join(self.config['remote_user'],
                                       'AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\',
                                       'launcher.vbs')
            startup_file = ntpath.join(self.config['remote_path'], 'launcher.vbs')
            self.ssh_object.send_command('mklink "{}" "{}"'.format(startup_link, startup_file))

    def send_vm_ssh_shutdown(self):
        self.config_check('Please specify configuration with process_config before attempting to connect to a vm via'
                          'ssh/sftp')
        self.vm_check('Please attach a vm with attach_vm attempting to connect to the vm via ssh/sftp')
        self.ssh_check('Please start an ssh session with the vm using start_vm_ssh_session before attempting to shut '
                       'it down via ssh')
        self.logfile.write('\tSending shutdown command to {} through SSH.\n'.format(self.ip_address))
        success = False
        if self.config['remote_type'] == 'windows':
            self.ssh_object.send_command('shutdown /s /t 0')
        else:
            self.ssh_object.send_sudo_command('sudo -S -p '' poweroff'.format(),
                                              password=self.config['remote_password'])
        self.ssh_object.close()
        sleep(self.config['shutdown_delay'])
        for i in range(0, self.config['timeout_seconds'] * 10):
            if self.vm_object.check_vm_shutdown():
                success = True
                break
            sleep(.1)
        if not success:
            raise RuntimeError('Failed to shutdown VM')
        return success

    # The following functions primarily involve the forensic wrapper utilities. These utilities may perform tasks
    # associated with other groups of functions (i.e. vboxmanage calls), but these utilities generally will perform
    # these tasks through shell commands

    # This function makes a raw disk copy of a virtual disk and compares the hash of the original to the hash of the
    # copy, returning True if the hashes are equal
    def clone_vm_disk(self):
        self.config_check('Please specify configuration with process_config before cloning a disk')
        self.vm_check('Please attach a vm with attach_vm before cloning its disk')
        self.logfile.write('Cloning raw drive.\n')
        if not self.fw_object:
            self.fw_object = fw.ForensicUtility()
            if self.module_logging:
                self.fw_object.set_logfile(path.join(self.config['log_path'], self.virus_name + "_" + self.time_string
                                                     + '__forensic__' + '.log'))
        self.working_filename = self.virus_name + "_" + 'working_' + self.time_string + '.raw'
        self.working_path = path.join(self.config['image_path'], self.working_filename)
        self.vm_hash = self.fw_object.vboxmanage_clone_and_verify(input_file=self.config['vm_path'],
                                                                  output_file=self.working_path,
                                                                  offset=self.config['compare_offset'],
                                                                  supplied_hash=self.vm_hash)
        if not self.vm_hash:
            self.logfile.write('\tFailed to identically clone {} to {} - application terminating unsuccessfully.'
                               '\n'.format(self.config['vm_path'], path.join(self.config['image_path'],
                                                                             self.working_path)))
            raise RuntimeError('Failed to clone drive')
        self.logfile.write('\tSuccessfully cloned {} as {}\n'.format(self.config['vm_path'], self.working_path))
        if self.vm_hash:
            return True

    # This function returns the UUID of a cloned drive
    def get_clone_disk_uuid(self):
        self.config_check("Please specify configuration with process_config before attempting get the cloned disk's"
                          "UUID")
        self.cloned_check("Please clone virtual disk with clone_vm_disk before attempting to get the cloned disk's"
                          "UUID")
        uuid = self.fw_object.get_uuid_from_virtual_disk(self.working_path)
        self.logfile.write('UUID: {}\n'.format(uuid))
        return uuid

    def close(self):
        if self.ssh_object:
            self.ssh_object.close()
        if self.fw_object:
            self.fw_object.close()
        if self.revert_drive_attachment_required:
            if not self.vm_object.check_vm_shutdown():
                self.shutdown_vm()
            self.revert_drive_attachment()
        elif self.vm_object:
            if not self.vm_object.check_vm_shutdown():
                self.shutdown_vm()
            self.vm_object.close()
            self.vm_object = None

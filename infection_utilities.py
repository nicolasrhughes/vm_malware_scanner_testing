import vbox_wrapper as vm
import forensic_wrapper as fw
import ssh_sftp_wrapper as ssh
import argparse
from os import path
from os import mkdir
import ntpath
import posixpath
from sys import stdout
from time import sleep
from datetime import datetime


class InfectionUtilities:

    MODULE_LOGGING = 4
    MAIN_LOGGING = 2
    NO_LOGGING = 0

    WINDOWS_SLEEP_FACTOR = 1000

    def __init__(self):
        self.config = {}
        self.module_logging = False
        self.logfile = stdout
        self.virus_name = ''
        self.vm_object = None
        self.vm_log = None
        self.fw_object = None
        self.fw_log = None
        self.ssh_object = None
        self.ssh_log = None
        self.vs_log = None
        self.vm_hash = ''
        self.time_string = datetime.now().strftime('%Y-%m-%d_%H%M%S')
        self.working_filename = ''
        self.working_path = ''
        self.revert_drive_attachment_required = False
        self.ip_address = ''
        self.full_launcher_path = ''

    # Parses input, looking for -c (--config) /path/to/config_file.txt or -l (--logging) [verbose OR module OR full]
    # to accept user-input config file and logging options. Full = module and main, verbose = main, and module = module
    @staticmethod
    def parse_config_file():
        parser = argparse.ArgumentParser(description='Create malware-infected VM images for tool testing. Please read '
                                                     'README.md for more details.')
        parser.add_argument('-c', '--config', type=str, nargs='?',
                            help='Path to configuration file. The program assumes the config is located'
                                 ' at ./config.txt if no configuration file is specified.')
        parser.add_argument('-l', '--logging', type=str, nargs='?', choices=('verbose', 'module', 'full'),
                            help='Options: verbose, module, full. The type of logging desired. Default is to output to '
                                 'STDOUT. "verbose" will log only high level operations, "module-level" will only log '
                                 'module output, and "full" provides both high-level and module-level logging.')
        return parser.parse_args()

    # Initalize variables. This creates some new derivative directories in the self.config[] dictionary
    def process_config(self, filename):
        self.config = {}
        with open(filename) as config_file:
            for line in config_file:
                variable, value = line.strip().split(': ', 1)
                self.config[variable] = value
        if not path.isdir(self.config['project_path']):
            mkdir(self.config['project_path'])
        self.config['vm_path'] = path.join(self.config['project_path'], 'base', 'base.raw')
        self.config['log_path'] = path.join(self.config['project_path'], 'log')
        if not path.isdir(self.config['log_path']):
            mkdir(self.config['log_path'])
        self.config['reference_path'] = path.join(self.config['project_path'], 'reference')
        self.config['log_path'] = path.join(self.config['project_path'], 'log')
        InfectionUtilities.check_or_make_path(self.config['log_path'])
        self.config['reference_path'] = path.join(self.config['project_path'], 'reference')
        InfectionUtilities.check_or_make_path(self.config['reference_path'])
        self.config['output_path'] = path.join(self.config['project_path'], 'output')
        InfectionUtilities.check_or_make_path(self.config['output_path'])
        self.config['image_path'] = path.join(self.config['project_path'], 'image')
        InfectionUtilities.check_or_make_path(self.config['image_path'])
        self.config['launcher_path'] = path.join(self.config['project_path'], 'utilities')
        InfectionUtilities.check_or_make_path(self.config['launcher_path'])
        self.config['remote_port'] = int(self.config['remote_port'])
        self.config['timeout_seconds'] = int(self.config['timeout_seconds'])
        self.config['block_size'] = int(self.config['block_size'])
        self.config['compare_offset'] = int(self.config['compare_offset']) * self.config['block_size']
        self.config['boot_delay'] = int(self.config['boot_delay'])
        self.config['ip_delay'] = int(self.config['ip_delay'])
        self.config['shutdown_delay'] = int(self.config['shutdown_delay'])
        self.config['startup_wait'] = int(self.config['startup_wait'])
        self.config['noriben_start_wait'] = int(self.config['noriben_start_wait'])
        self.config['infect_wait'] = int(self.config['infect_wait'])
        self.config['noriben_close_wait'] = int(self.config['noriben_close_wait'])
        return self.config

    # Check to see if <target_path> exists. If so, do nothing. If not, create the path.
    @staticmethod
    def check_or_make_path(target_path):
        if not path.isdir(target_path):
            mkdir(target_path)

    # Make sure the module is configured before proceeding
    def config_check(self, error_string='No configuration file specified. Use process_config before proceeding.'):
        if not self.config:
            raise AttributeError(error_string)

    # Check to see if we have created a VM object before running VM operations
    def vm_check(self, error_string='No VM attached. Use attach_vm before proceeding.'):
        if not self.vm_object:
            raise AttributeError(error_string)

    # Check to see if the forensic_wrapper exists. We need the wrapper for some of our vboxmanage commands and hashing
    # functions
    def fw_check(self, error_string='Forensic wrapper not initialized. Use please use a method that creates a fw'
                                    'object before proceeding.'):
        if not self.fw_object:
            raise AttributeError(error_string)

    # Check to see if we have a cloned disk that we can infect
    def cloned_check(self, error_string='No cloned VM disk detected. Use clone_vm_disk before proceeding.'):
        if not self.working_filename or not self.working_path:
            raise AttributeError(error_string)

    # Check to see if we have an ip address before starting operations that depend on it
    def ip_check(self, error_string='No VM IP address reported. Use start_vm and ensure VM network is configured'
                                    'appropiately before proceeding.'):
        if not self.ip_address:
            raise AttributeError(error_string)

    # Check to see if we have an ssh_object before starting ssh operations
    def ssh_check(self, error_string='No SSH session reported. Use start_vm_ssh_session before proceeding.'):
        if not self.ssh_object:
            raise AttributeError(error_string)

    # Set both main and module logging based on <logging_type>. Options, MAIN_LOGGING, MODULE_LOGGING, MAIN_LOGGING |
    # MODULE_LOGGING.
    def set_logging(self, logging_type):
        if not self.config:
            raise AttributeError('Logging requested before specifying log configuration')
        if (logging_type and self.MAIN_LOGGING) == self.MAIN_LOGGING:
            self.logfile = open(path.join(self.config['log_path'], self.virus_name + "_" + self.time_string +
                                          '__main__' + '.log'), 'w')
        if (logging_type and self.MODULE_LOGGING) == self.MODULE_LOGGING:
            self.module_logging = True

    # This returns the virus_path specified by config['virus_path']
    def get_virus_path(self):
        self.config_check('Please specify configuration with process_config before attempting to return paths')
        return self.config['virus_path']

    # After we create the vbscript launcher, we can use this function to get its path
    def get_full_launcher_path(self):
        if not self.full_launcher_path:
            raise AttributeError('Please call create_windows_launcher before proceeding')
        return self.full_launcher_path

    # This can be used for testing purposes if you want to set the virus name manually to <virus>
    def set_virus_name(self, virus):
        self.virus_name = virus

    # The following functions primarily involve virtualbox commands sent through our virtualbox wrapper for the python
    # virtualbox module
    def attach_vm(self):
        self.config_check('Please specify configuration with process_config before attempting to attach a vm')
        self.logfile.write('Starting virtual machine module.\n')
        self.vm_object = vm.VMManage()
        if self.module_logging:
            self.vm_object.set_logfile(path.join(self.config['log_path'], self.virus_name + "_" + self.time_string +
                                                 '__vm__' + '.log'))
        self.logfile.write('Setting logfile.\n')
        self.logfile.write('Setting VM from path {}.\n'.format(self.config['vm_path']))
        self.vm_object.set_vm(vm_disk_path_string=self.config['vm_path'], vm_manager_value=vm.VMManage.VIRTUALBOX,
                              vm_timeout_value=self.config['timeout_seconds'])
        if self.vm_object:
            return True

    # Attach the cloned drive to the virtual machine
    def attach_cloned_drive(self):
        self.config_check('Please specify configuration with process_config before attaching a cloned disk')
        self.vm_check('Please attach a vm with attach_vm before cloning its disk')
        self.cloned_check('Please clone VM using clone_vm_disk before trying to attach the cloned disk to the vm')
        # Attach clone drive to target virtual machine
        self.logfile.write('Opening cloned drive.\n')
        self.vm_object.print_attachments()
        self.vm_object.open_drive(self.working_path)
        self.logfile.write('Attaching cloned drive.\n')
        success = self.vm_object.attach_opened_medium()
        self.vm_object.print_attachments()
        self.revert_drive_attachment_required = True
        return success

    # Revert to the original drive attachment from the cloned drive
    def revert_drive_attachment(self):
        self.config_check('Please specify configuration with process_config before attaching a cloned disk')
        self.vm_check('Please attach a vm with attach_vm before cloning its disk')
        self.cloned_check('Please clone VM using clone_vm_disk before trying to attach the cloned disk to the vm')
        self.vm_object.wait_for_vm_unlock()
        success = self.vm_object.reattach_original_medium()
        self.vm_object.print_attachments()
        self.revert_drive_attachment_required = False
        return success

    # Start VM
    def start_vm(self):
        self.config_check('Please specify configuration with process_config before starting a vm')
        self.vm_check('Please attach a vm with attach_vm before cloning its disk')
        self.logfile.write('Starting VM.\n')
        self.vm_object.start_vm()
        sleep(self.config['boot_delay'])
        return True

    # Get the VM's IP address
    def attach_vm_ip(self):
        self.logfile.write('Obtaining IP from VM.\n')
        self.ip_address = self.vm_object.obtain_vm_ip()
        sleep(self.config['ip_delay'])
        return self.ip_address

    # Shutdown the VM forcibly
    def shutdown_vm(self):
        self.config_check('Please specify configuration with process_config before attempting shutdown a VM')
        self.vm_check('Please attach a vm before attempting to shut it down')
        self.logfile.write('\tSending shutdown command to {} through virtualbox API.\n'.format(self.config['vm_name']))
        self.vm_object.vm_shutdown()

    # These functions involve SSH/SFTP commands sent through the Paramiko wrapper

    # This function starts a Paramiko connection, relies on the ssh/sftp wrapper to throw exceptions, and returns
    # True if successful
    def start_vm_ssh_session(self):
        self.config_check('Please specify configuration with process_config before attempting to connect to a vm via'
                          'ssh/sftp')
        self.vm_check('Please attach a vm with attach_vm attempting to connect to the vm via ssh/sftp')
        self.ip_check('Please start the vm with start_vm before attempting to connect via ssh/sftp')
        # Establish SSH connection to VM
        self.logfile.write('\tAttempting to obtain SSH/SFTP connection to {}.\n'.format(self.ip_address))
        self.ssh_object = ssh.SSHManage()
        if self.module_logging:
            self.ssh_object.set_logfile(path.join(self.config['log_path'], self.virus_name + "_" + self.time_string +
                                                  '__ssh__' + '.log'))
        self.ssh_object.configure_connection(self.ip_address, username=self.config['remote_username'],
                                             password=self.config['remote_password'], port=self.config['remote_port'])
        for i in range(0, self.config['timeout_seconds']):
            if self.ssh_object.start_connection():
                return True
            elif i == self.config['timeout_seconds'] - 1:
                self.logfile.write('Failed to establish SSH/SFTP connection - application terminating '
                                   'unsuccessfully.\n')
                raise RuntimeError('Failed to establish SSH/SFTP connection')
            sleep(.1)

    # This function starts a Paramiko SFTP session,relies on the ssh/sftp wrapper to throw exceptions, and returns
    # True if successful
    def start_vm_sftp_session(self):
        self.config_check('Please specify configuration with process_config before attempting to connect to a vm via'
                          'ssh/sftp')
        self.vm_check('Please attach a vm with attach_vm attempting to connect to the vm via ssh/sftp')
        self.ssh_check('Please start an ssh session with the vm using start_vm_ssh_session before attempting to '
                       'send it files via sftp')
        self.logfile.write('Starting SFTP connection with {}'.format(self.ip_address))
        self.ssh_object.start_connection()
        if self.ssh_object.start_sftp():
            return True

    # This function closes a Paramiko SFTP session, relies on the ssh/sftp wrapper to throw exceptions, and returns
    # True if successful
    def close_vm_sftp_session(self):
        self.config_check('Please specify configuration with process_config before attempting to close the sftp '
                          'session')
        self.vm_check('Please attach a vm with attach_vm attempting to close the sftp session')
        if self.ssh_object:
            self.logfile.write('Closing SFTP connection with {}'.format(self.ip_address))
            if self.ssh_object.close_sftp():
                return True

    # This function puts a single directory or file to a remote Paramiko SFTP session and relies on the ssh/sftp
    # wrapper to throw exceptions
    def send_vm_sftp_file_or_dir(self, item_path, remote_subdirectory=''):
        if not remote_subdirectory:
            remote_path = self.config['remote_path']
            remote_ftp_path = self.config['remote_ftp_path']
        else:
            if self.config['remote_type'] == 'windows':
                remote_path = ntpath.join(self.config['remote_path'], remote_subdirectory)
            else:
                remote_path = posixpath.join(self.config['remote_path'], remote_subdirectory)
            remote_ftp_path = posixpath.join(self.config['remote_ftp_path'], remote_subdirectory)
        if path.isdir(item_path):
            self.logfile.write('\tOverwriting remote contents at {} with local contents at {}.'
                               '\n'.format(remote_path, item_path))
            self.ssh_object.delete_recreate_and_put_directory(input_directory=item_path,
                                                              output_ftp_directory=remote_ftp_path,
                                                              output_directory=remote_path,
                                                              os_type=self.config['remote_type'])
        else:
            self.logfile.write('\tPutting local file {} to {}\n'.format(item_path, remote_ftp_path))
            if self.config['remote_type'] == 'windows':
                self.ssh_object.put(input_path=item_path, output_path=ntpath.join(remote_ftp_path,
                                                                                  path.basename(item_path)))
            else:
                self.ssh_object.put(input_path=item_path, output_path=posixpath.join(remote_ftp_path,
                                                                                     path.basename(item_path)))

    # Create the vbscript that we will use as a malware and Noriben launcher
    def create_windows_launcher(self, item):
        if not self.fw_object:
            self.fw_object = fw.ForensicUtility()
        startup_wait = InfectionUtilities.WINDOWS_SLEEP_FACTOR * self.config['startup_wait']
        noriben_start_wait = InfectionUtilities.WINDOWS_SLEEP_FACTOR * self.config['noriben_start_wait']
        infect_wait = InfectionUtilities.WINDOWS_SLEEP_FACTOR * self.config['infect_wait']
        noriben_close_wait = InfectionUtilities.WINDOWS_SLEEP_FACTOR * self.config['noriben_close_wait']
        self.fw_object.create_windows_launcher(self.config['launcher_path'], self.config['remote_path'], item,
                                               startup_wait, noriben_start_wait, infect_wait, noriben_close_wait)
        self.full_launcher_path = path.join(self.config['launcher_path'], 'launcher.vbs')

    # Point to the right directory for Startup
    def setup_startup_link(self):
        self.config_check('Please specify configuration with process_config before attempting to connect to a vm via'
                          'ssh/sftp')
        self.vm_check('Please attach a vm with attach_vm attempting to connect to the vm via ssh/sftp')
        self.ssh_check('Please start an ssh session with the vm using start_vm_ssh_session before attempting to shut '
                       'it down via ssh')
        self.fw_check('Please set the malware path before activating batch file')
        self.logfile.write('\tCreating startup link to vbscript file on {} using SSH.\n'.format(self.ip_address))
        success = False
        if self.config['remote_type'] == 'windows':
            startup_link = ntpath.join(self.config['remote_user'],
                                       'AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\',
                                       'launcher.vbs')
            startup_file = ntpath.join(self.config['remote_path'], 'launcher.vbs')
            self.ssh_object.send_command('mklink "{}" "{}"'.format(startup_link, startup_file))


    # Send VM a shutdown command through the SSH shell
    def send_vm_ssh_shutdown(self):
        self.config_check('Please specify configuration with process_config before attempting to connect to a vm via'
                          'ssh/sftp')
        self.vm_check('Please attach a vm with attach_vm attempting to connect to the vm via ssh/sftp')
        self.ssh_check('Please start an ssh session with the vm using start_vm_ssh_session before attempting to shut '
                       'it down via ssh')
        self.logfile.write('\tSending shutdown command to {} through SSH.\n'.format(self.ip_address))
        success = False
        if self.config['remote_type'] == 'windows':
            self.ssh_object.send_command('shutdown /s /t 0')
        else:
            self.ssh_object.send_sudo_command('sudo -S -p '' poweroff'.format(),
                                              password=self.config['remote_password'])
        self.ssh_object.close()
        sleep(self.config['shutdown_delay'])
        for i in range(0, self.config['timeout_seconds'] * 10):
            if self.vm_object.check_vm_shutdown():
                success = True
                break
            sleep(.1)
        if not success:
            raise RuntimeError('Failed to shutdown VM')
        return success

    # The following functions primarily involve the forensic wrapper utilities. These utilities may perform tasks
    # associated with other groups of functions (i.e. vboxmanage calls), but these utilities generally will perform
    # these tasks through shell commands

    # This function makes a raw disk copy of a virtual disk and compares the hash of the original to the hash of the
    # copy, returning True if the hashes are equal
    def clone_vm_disk(self):
        self.config_check('Please specify configuration with process_config before cloning a disk')
        self.vm_check('Please attach a vm with attach_vm before cloning its disk')
        self.logfile.write('Cloning raw drive.\n')
        if not self.fw_object:
            self.fw_object = fw.ForensicUtility()
            if self.module_logging:
                self.fw_object.set_logfile(path.join(self.config['log_path'], self.virus_name + "_" + self.time_string
                                                     + '__forensic__' + '.log'))
        self.working_filename = self.virus_name + "_" + 'working_' + self.time_string + '.raw'
        self.working_path = path.join(self.config['image_path'], self.working_filename)
        self.vm_hash = self.fw_object.vboxmanage_clone_and_verify(input_file=self.config['vm_path'],
                                                                  output_file=self.working_path,
                                                                  supplied_hash=self.vm_hash)
        if not self.vm_hash:
            self.logfile.write('\tFailed to identically clone {} to {} - application terminating unsuccessfully.'
                               '\n'.format(self.config['vm_path'], path.join(self.config['image_path'],
                                                                             self.working_path)))
            raise RuntimeError('Failed to clone drive')
        self.logfile.write('\tSuccessfully cloned {} as {}\n'.format(self.config['vm_path'], self.working_path))
        if self.vm_hash:
            return True

    # This function returns the UUID of a cloned drive
    def get_clone_disk_uuid(self):
        self.config_check("Please specify configuration with process_config before attempting get the cloned disk's"
                          "UUID")
        self.cloned_check("Please clone virtual disk with clone_vm_disk before attempting to get the cloned disk's"
                          "UUID")
        uuid = self.fw_object.get_uuid_from_virtual_disk(self.working_path)
        self.logfile.write('UUID: {}\n'.format(uuid))
        return uuid

    # Close the open modules, revert the drive attachment
    def close(self):
        if self.ssh_object:
            self.ssh_object.close()
        if self.fw_object:
            self.fw_object.close()
        if self.revert_drive_attachment_required:
            if not self.vm_object.check_vm_shutdown():
                self.shutdown_vm()
            self.revert_drive_attachment()
        elif self.vm_object:
            if not self.vm_object.check_vm_shutdown():
                self.shutdown_vm()
            self.vm_object.close()
            self.vm_object = None

import os
import re
import mmap
import hashlib
from shutil import copy
import sys
from subprocess import run, PIPE
from io import TextIOWrapper


class ForensicUtility:

    MD5 = MD5_ONLY = 0
    SHA1 = SHA1_ONLY = 1
    MD5_AND_SHA1 = SHA1_AND_MD5 = 2

    losetup_regex = "/dev/loop[0-9]+"
    md5_sum_regex = "^[0-9a-fA-F]{32}"
    sha1_sum_regex = "^[0-9a-fA-F]{40}"

    CLAMSCAN = 0
    SAVSCAN = 1
    CMDSCAN = 2
    FPSCAN = 3

    CLAMSCAN_NAME = "clamscan"
    SAVSCAN_NAME = "savscan"
    CMDSCAN_NAME = "cmdscan"
    FPSCAN_NAME = "fpscan"

    clamscan_regex = """^(.*):(.*) FOUND$"""
    savscan_regex = """^>>> Virus '(.*)' found in file (.*)$"""
    cmdscan_regex = """^(.*) ---> Found .* Name is(.*)$"""
    fpscan_regex = """\[Found.*\]\s<(.*\))>\s*(/.*)"""

    savscan_version_regex_1 = """^Product version\s*:\s([0-9.]+[0-9.]+[0-9])"""
    savscan_version_regex_2 = """Engine version\s*:\s*([0-9.]+[0-9.]+[0-9])"""
    savscan_version_regex_3 = """Virus data version \s*:\s*([0-9.]+[0-9.]+[0-9])"""
    clamscan_version_regex = """ClamAV\s*([0-9.]*)\/[0-9]*\/([FMSTW].*[0-9]{4})"""
    fpscan_version_regex_1 = """^F-PROT Antivirus .* version ([0-9.]*)"""
    fpscan_version_regex_2 = """^Engine version:\s*([0-9.]*)"""
    fpscan_version_regex_3 = """^Virus signatures:\s([0-9]*)"""

    def __init__(self):
        self.logfile = sys.stdout

    def set_logfile(self, logfile_path):
        self.logfile = open(logfile_path, "w")

    def set_logfile_by_directory(self, logfile_directory):
        self.logfile = open(os.path.join(logfile_directory, "forensic_utility.log"), "w")

    def flush_logfile(self):
        self.logfile.flush()

    def close_logfile(self):
        if self.logfile != sys.stdout:
            self.logfile.close()

    def close(self):
        self.close_logfile()

    def vboxmanage_clone_and_verify(self, input_file, output_file, supplied_hash=[], offset=0, mode=MD5_ONLY):
        self.logfile.write("Running vboxmanage clonehd command on file {}\n".format(input_file))
        clone_result = run("vboxmanage clonehd {} {}".format(input_file, output_file), shell=True,
                           encoding='utf-8', stdout=PIPE)
        if clone_result:
            if not supplied_hash:
                self.logfile.write("\tCalculating hash of input file {}\n".format(input_file))
                original_hash = self.file_checksums_parallel(input_file, offset, mode)
                if original_hash:
                    self.logfile.write("\t\tHash of input file {} successfully calculated"
                                       ": {}\n".format(input_file, original_hash))
                else:
                    self.logfile.write("\tFailed to calculate hash of input file {}\n".format(input_file))
                    raise ValueError("Could not calculate input file hash value")
            else:
                self.logfile.write("\tUsing supplied hash value of {}\n".format(supplied_hash))
                original_hash = supplied_hash
            self.logfile.write("\tCalculating hash of clone file {}\n".format(output_file))
            clone_hash = self.file_checksums_parallel(output_file, offset, mode)
            if clone_hash:
                self.logfile.write("\t\tHash of clone file {} successfully calculated"
                                   ": {}\n".format(output_file, clone_hash))
            else:
                self.logfile.write("\tFailed to calculate hash of input file {}\n".format(input_file))
                raise ValueError("Could not calculate clone file hash value")
            if clone_hash == original_hash:
                return original_hash
        self.logfile.write("Failed to clone file {}\n")
        return []

    def external_checksum_string(self, input_file, hash_type, offset=0, read_length=0):
        if hash_type == ForensicUtility.MD5:
            command = "md5sum"
        elif hash_type == ForensicUtility.SHA1:
            command = "sha1sum"
        else:
            command = ""
        if read_length:
            return "dd if={} skip={} count={} status=none iflag=skip_bytes | {}".format(input_file, offset, read_length,
                                                                                        command)
        elif offset:
            return "dd if={} skip={} status=none iflag=skip_bytes | {}".format(input_file, offset, command)
        else:
            return "{} {}".format(command, input_file)

    def external_file_checksums(self, input_file, offset=0, read_length=0, mode=MD5_ONLY):
        self.logfile.write("Attempting to appropriately invoke hashing functions on file {}\n".format(input_file))
        output = []
        if mode != ForensicUtility.SHA1_ONLY:
            md5_result = run(self.external_checksum_string(input_file, ForensicUtility.MD5, offset, read_length),
                             shell=True, encoding='utf-8', stdout=PIPE)
            if md5_result != 0:
                for line in md5_result.stdout.split("\n"):
                    if line and not(line.isspace()):
                        md5_hash_match = re.match(ForensicUtility.md5_sum_regex, line)
                        if md5_hash_match:
                            output.append(md5_hash_match[0])
        if mode != ForensicUtility.MD5_ONLY:
            sha1_result = run(self.external_checksum_string(input_file, ForensicUtility.SHA1, offset, read_length),
                              shell=True, encoding='utf-8', stdout=PIPE)
            if sha1_result != 0:
                for line in sha1_result.stdout.split("\n"):
                    if line and not(line.isspace()):
                        sha1_hash_match = re.match(ForensicUtility.sha1_sum_regex, line)
                        if sha1_hash_match:
                            output.append(sha1_hash_match[0])
        if output != []:
            self.logfile.write("Hashing functions returned result {} for file {}\n".format(output, input_file))
            return output
        self.logfile.write("Hashing functions failed for file {}\n".format(input_file))
        return []

    def read_chunks(self, input_handle, chunk_size=4096, read_length=0):
        data_read = 0
        while True:
            if read_length:
                if read_length - data_read <= 0:
                    break
                elif read_length - data_read < chunk_size:
                    data = input_handle.read(read_length - data_read)
                else:
                    data = input_handle.read(chunk_size)
                data_read += chunk_size
                if not data:
                    break
                yield data
            else:
                data = input_handle.read(chunk_size)
                if not data:
                    break
                yield data

    def file_checksums_mmap_parallel(self, input_file, offset=0, read_length=0, chunk_size=1024, mode=MD5_ONLY):
        output = []
        with open(input_file, "rb") as read_file:
            read_map = mmap.mmap(read_file.fileno(), length=read_length, offset=offset, access=mmap.PROT_READ)
            if (mode != ForensicUtility.SHA1_ONLY) and (mode != ForensicUtility.MD5_ONLY) \
                    and (mode != ForensicUtility.MD5_AND_SHA1):
                raise ValueError("Mode {} is not permitted".format(mode))
            if mode != ForensicUtility.SHA1_ONLY:
                md5_hash = hashlib.md5()
            if mode != ForensicUtility.MD5_ONLY:
                sha1_hash = hashlib.sha1()
            for chunk in self.read_chunks(read_map, chunk_size, 0):
                if mode != ForensicUtility.SHA1_ONLY:
                    md5_hash.update(chunk)
                if mode != ForensicUtility.MD5_ONLY:
                    sha1_hash.update(chunk)
        if mode != ForensicUtility.SHA1_ONLY:
            if md5_hash.hexdigest():
                output.append(md5_hash.hexdigest())
        if mode != ForensicUtility.MD5_ONLY:
            if sha1_hash.hexdigest():
                output.append(sha1_hash.hexdigest())
        return output

    def file_checksums_parallel(self, input_file, offset=0, read_length=0, chunk_size=4096, mode=MD5_ONLY):
        output = []
        with open(input_file, "rb") as read_file:
            read_file.seek(offset)
            if (mode != ForensicUtility.SHA1_ONLY) and (mode != ForensicUtility.MD5_ONLY) \
                    and (mode != ForensicUtility.MD5_AND_SHA1):
                raise ValueError("Mode {} is not permitted".format(mode))
            if mode != ForensicUtility.SHA1_ONLY:
                md5_hash = hashlib.md5()
            if mode != ForensicUtility.MD5_ONLY:
                sha1_hash = hashlib.sha1()
            for chunk in self.read_chunks(read_file, chunk_size, read_length):
                if mode != ForensicUtility.SHA1_ONLY:
                    md5_hash.update(chunk)
                if mode != ForensicUtility.MD5_ONLY:
                    sha1_hash.update(chunk)
        if mode != ForensicUtility.SHA1_ONLY:
            if md5_hash.hexdigest():
                output.append(md5_hash.hexdigest())
        if mode != ForensicUtility.MD5_ONLY:
            if sha1_hash.hexdigest():
                output.append(sha1_hash.hexdigest())
        return output

    def file_checksums(self, input_file, offset=0, read_length=0, mode=MD5_ONLY):
        with open(input_file, "rb") as read_file:
            output = []
            if read_length == 0:
                read_file_size = os.path.getsize(input_file)
                read_length = read_file_size - offset
            if mode != ForensicUtility.SHA1_ONLY:
                output.append(hashlib.md5(mmap.mmap(fileno=read_file.fileno(), length=read_length, prot=mmap.PROT_READ,
                                                    offset=offset)).hexdigest())
            if mode != ForensicUtility.MD5_ONLY:
                output.append(hashlib.sha1(mmap.mmap(read_file.fileno(), read_length, prot=mmap.PROT_READ,
                                                     offset=offset)).hexdigest())
        return output

    def copy_and_verify_file(self, input_file, output_file, supplied_checksums=[]):
        copy(input_file, output_file)
        if supplied_checksums == []:
            input_checksums = self.file_checksums(input_file)
        else:
            input_checksums = supplied_checksums
        output_checksums = self.file_checksums(output_file)
        if input_checksums == output_checksums:
            return input_checksums
        else:
            return None

    def clone_raw_vmdk(self, vmdk_file_path, output_folder, output_file_name=""):
        raw_file_name = ""
        replace_line = ""
        with open(vmdk_file_path, "r") as vmdk_reader:
            for line in vmdk_reader:
                line_values = line.split(" ")
                if len(line_values) >= 4:
                    if (line_values[0] in {"RW", "RDONLY", "NOACCESS"}) and line_values[1].isdigit and line_values[2] \
                        in {"FLAT", "SPARSE", "ZERO", "VMFS", "VMFSSPARSE", "VMFSRDM", "VMFSRAW"} and \
                            line_values[-1].strip().isdigit():
                        raw_file_name = " ".join(line_values[3:-1]).strip('"')
                        replace_line = line
                        break
        raw_file_path = os.path.join(os.path.split(vmdk_file_path)[0], raw_file_name)
        if output_file_name:
            new_raw_file_name = output_file_name + ".raw"
        else:
            new_raw_file_name = raw_file_name
        # REMOVE COMMENT - FOR DEBUGGING ONLY
        self.logfile.write("\tCopying {} to {}.\n".format(raw_file_path, os.path.join(output_folder,
                                                                                      new_raw_file_name)))
        self.copy_and_verify_file(raw_file_path, os.path.join(output_folder, new_raw_file_name))
        new_vmdk_file_name = re.sub(".raw$", ".vmdk", new_raw_file_name)
        new_vmdk_file_path = os.path.join(output_folder, new_vmdk_file_name)
        copy(vmdk_file_path, new_vmdk_file_path)
        if raw_file_name != output_file_name:
            file_contents = ""
            with open(new_vmdk_file_path, "r") as vmdk_reader:
                for line in vmdk_reader:
                    if line == replace_line:
                        file_contents += line.replace(raw_file_name, new_raw_file_name)
                    else:
                        file_contents += line
            with open(new_vmdk_file_path, "w") as vmdk_writer:
                vmdk_writer.writelines(file_contents)
        return [new_vmdk_file_name, new_raw_file_name]

    def safemount_image(self, image_file):
        self.logfile.write("Attempting to mount {} safely to loopback\n".format(image_file))
        safemount_result = run("udisksctl loop-setup -r -f  {}".format(image_file), shell=True,
                               encoding='utf-8', stdout=PIPE)
        if safemount_result != 0:
            self.logfile.write("\tMounted filesystem {}\n".format(image_file))
            return True
        self.logfile.write("Failed to mount filesystem {}\n".format(image_file))
        return False

    def safeunmount_image(self, image_file):
        self.logfile.write("Attempting to find loopback device associated with {}\n".format(image_file))
        loopback_result = run("losetup -j  {}".format(image_file), shell=True, encoding='utf-8', stdout=PIPE)
        if loopback_result != 0:
            for line in loopback_result.stdout.split("\n"):
                if line and not(line.isspace()):
                    loopback_match = re.search(self.losetup_regex, line)
                    if loopback_match:
                        loopback_result = loopback_match.group(0)
                        self.logfile.write("Attempting to delete loopback device {} associated with "
                                           "{}\n".format(loopback_result, image_file))
                        run("losetup -d {}".format(loopback_result), shell=True, encoding='utf-8', stdout=PIPE)
            if loopback_result != 0:
                self.logfile.write("Unmounted loopback device {} associated with {}\n".format(loopback_result,
                                                                                              image_file))
                return True
        self.logfile.write("Failed to mount filesystem {}\n".format(image_file))
        return False

    def mount_image(self, image_file, mount_point, offset):
        self.logfile.write("Attempting to mount {} to {}\n".format(image_file, mount_point))
        mount_result = run('mount -o ro,loop,offset={} {} {}'.format(offset, image_file, mount_point), shell=True,
                           encoding='utf-8', stdout=PIPE)
        if mount_result != 0:
            self.logfile.write("\tMounted filesystem {}\n".format(mount_point))
            return True
        self.logfile.write("Failed to mount filesystem at {} to {}\n".format(image_file, mount_point))
        return False

    def unmount_image(self, mount_point):
        self.logfile.write("Attempting to unmount raw filesystem mapped to {}\n".format(mount_point))
        unmount_result = run('umount {}'.format(mount_point), shell=True, encoding='utf-8', stdout=PIPE)
        if unmount_result != 0:
            self.logfile.write("\tUnmounted loopback device mounted at {}\n".format(mount_point))
            return True
        self.logfile.write("Failed to unmount filesystem mounted at {}\n".format(mount_point))
        return False

    def nopasswd_mount_image(self, image_file, mount_point, offset):
        self.logfile.write("Attempting to mount {} to {}\n".format(image_file, mount_point))
        mount_result = run('sudo mount -o ro,loop,offset={} {} {}'.format(offset, image_file, mount_point), shell=True,
                           stdout=PIPE, encoding="ascii")
        if mount_result != 0:
            self.logfile.write("\tMounted filesystem {}\n".format(mount_point))
            return True
        self.logfile.write("Failed to mount filesystem at {} to {}\n".format(image_file, mount_point))
        return False

    def nopasswd_unmount_image(self, mount_point):
        self.logfile.write("Attempting to unmount raw filesystem mapped to {}\n".format(mount_point))
        unmount_result = run('sudo umount {}'.format(mount_point), shell=True, encoding='ascii', stdout=PIPE)
        if unmount_result != 0:
            self.logfile.write("\tUnmounted loopback device mounted at {}\n".format(mount_point))
            return True
        self.logfile.write("Failed to unmount filesystem mounted at {}\n".format(mount_point))
        return False

    def sudo_mount_image(self, image_file, mount_point, offset, password):
        self.logfile.write("Attempting to mount {} to {}\n".format(image_file, mount_point))
        mount_result = run('sudo mount -o ro,loop,offset={} {} {}'.format(offset, image_file, mount_point), shell=True,
                           stdout=PIPE, input=password, encoding="ascii")
        if mount_result != 0:
            self.logfile.write("\tMounted filesystem {}\n".format(mount_point))
            return True
        self.logfile.write("Failed to mount filesystem at {} to {}\n".format(image_file, mount_point))
        return False

    def sudo_unmount_image(self, mount_point, password):
        self.logfile.write("Attempting to unmount raw filesystem mapped to {}\n".format(mount_point))
        unmount_result = run('sudo umount {}'.format(mount_point), shell=True, encoding='ascii', stdout=PIPE,
                             input=password)
        if unmount_result != 0:
            self.logfile.write("\tUnmounted loopback device mounted at {}\n".format(mount_point))
            return True
        self.logfile.write("Failed to unmount filesystem mounted at {}\n".format(mount_point))
        return False

    def get_uuid_from_virtual_disk(self, vm_disk_path):
            self.logfile.write("Attempting to determine UUID of virtual disk {}\n".format(vm_disk_path))
            uuid_result = run('vboxmanage showhdinfo "{}"'.format(vm_disk_path), shell=True, encoding='utf-8',
                              stdout=PIPE)
            if uuid_result != 0:
                for line in uuid_result.stdout.split("\n"):
                    if line[0:4] == "UUID":
                        self.logfile.write("UUID {} associated with virtual disk {}\n".format(line[6:].strip(),
                                                                                              vm_disk_path))
                        return line[6:].strip()
            return ""

    def analyze_chunk(self, search_path_list, target_folder, subsearch_size=1024*1024, read_segment_size=128*1024*1024):
        search_mmap_list = []
        search_sizes_list = []
        found_list = []
        for search_path in search_path_list:
            search_read_file = open(search_path, "r+")
            search_mmap = mmap.mmap(search_read_file.fileno(), 0)
            search_mmap_list.append(search_mmap)
            search_sizes_list.append(os.path.getsize(search_path))
        subsearch_mmap_list = []
        for i in range(len(search_mmap_list)):
            if subsearch_size > search_sizes_list[i]:
                subsearch_mmap_list.append(search_mmap_list[i])
            else:
                subsearch_mmap_list.append(search_mmap_list[i][:subsearch_size])
        target_files = os.listdir(target_folder)
        for target_file in target_files:
            target_path = os.path.join(target_folder, target_file)
            print(target_path)
            target_segment_start = 0
            target_segment_end = read_segment_size
            target_length = os.path.getsize(target_path)
            subsearch_hits = []
            while target_segment_start + subsearch_size < target_length:
                if target_segment_end >= target_length:
                    target_read_file = open(target_path, "r+")
                    target_mmap = mmap.mmap(target_read_file.fileno(), offset=target_segment_start,
                                            length=target_length - target_segment_start)
                else:
                    target_read_file = open(target_path, "r+")
                    target_mmap = mmap.mmap(target_read_file.fileno(), offset=target_segment_start,
                                            length=(read_segment_size + subsearch_size))
                for i in range(len(subsearch_mmap_list)):
                    index = target_mmap.find(subsearch_mmap_list[i])
                    if index > -1:
                        subsearch_hits.append([i, index+target_segment_start])
                        print(subsearch_hits[-1])
                target_segment_start += read_segment_size
                target_segment_end += read_segment_size
                target_read_file.close()
            subsearch_hits.sort(key=lambda x: x[1])
            for i in range(len(search_mmap_list)):
                target_read_file = open(target_path, "r+")
                target_read_length = search_sizes_list[i]
                for subsearch_hit in subsearch_hits:
                    if subsearch_hit[0] == i:
                        if subsearch_hit[1] + target_read_length < target_length:
                            offset_factor = subsearch_hit[1] // mmap.ALLOCATIONGRANULARITY
                            length_factor = target_read_length + subsearch_hit[1] % mmap.ALLOCATIONGRANULARITY
                            target_mmap = mmap.mmap(target_read_file.fileno(),
                                                    offset=offset_factor * mmap.ALLOCATIONGRANULARITY,
                                                    length=length_factor)
                            index = target_mmap.find(search_mmap_list[i])
                            if index > -1:
                                found_list.append([search_path_list[i], subsearch_hit[1], target_read_length])
                                print(found_list[-1])

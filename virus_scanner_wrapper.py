import re
from subprocess import run, PIPE
from sys import stdout
from os import path

class VirusScannerTesting:

    MIN_VIRUS_SCANNER = CLAMSCAN = 0
    SAVSCAN = 1
    CMDSCAN = 2
    MAX_VIRUS_SCANNER = FPSCAN = 3

    CLAMSCAN_NAME = "clamscan"
    SAVSCAN_NAME = "savscan"
    CMDSCAN_NAME = "cmdscan"
    FPSCAN_NAME = "fpscan"

    CLAMSCAN_COMMAND = "clamscan -r -i --no-summary"
    SAVSCAN_COMMAND = "savscan -ndi -ss {}"
    CMDSCAN_COMMAND = "cmdscan -v -s"
    FPSCAN_COMMAND = "fpscan -v 0 --report"

    CLAMSCAN_VERSION_COMMAND = "clamscan -V"
    SAVSCAN_VERSION_COMMAND = "savscan -V"
    #Note - at time of development, no version information available for CMDSCAN
    CMDSCAN_VERSION_COMMAND = ""
    FPSCAN_VERSION_COMMAND = "fpscan --version"

    clamscan_regex = """^(.*):(.*) FOUND$"""
    savscan_regex = """^>>> Virus '(.*)' found in file (.*)$"""
    cmdscan_regex = """^(.*) ---> Found .* Name is(.*)$"""
    fpscan_regex = """\[Found.*\]\s<(.*\))>\s*(/.*)"""

    savscan_version_regex_1 = """^Product version\s*:\s([0-9.]+[0-9.]+[0-9])"""
    savscan_version_regex_2 = """Engine version\s*:\s*([0-9.]+[0-9.]+[0-9])"""
    savscan_version_regex_3 = """Virus data version \s*:\s*([0-9.]+[0-9.]+[0-9])"""
    clamscan_version_regex = """ClamAV\s*([0-9.]*)\/[0-9]*\/([FMSTW].*[0-9]{4})"""
    fpscan_version_regex_1 = """^F-PROT Antivirus .* version ([0-9.]*)"""
    fpscan_version_regex_2 = """^Engine version:\s*([0-9.]*)"""
    fpscan_version_regex_3 = """^Virus signatures:\s([0-9]*)"""


    def __init__(self):
        self.logfile = stdout
        self.output_headers = {}

    def set_logfile(self, logfile_path):
        self.logfile = open(logfile_path, "w")

    def set_logfile_by_directory(self, logfile_directory):
        self.logfile = open(path.join(logfile_directory, "virus_scanner.log"), "w")

    def flush_logfile(self):
        self.logfile.flush()

    def close_logfile(self):
        if self.logfile != stdout:
            self.logfile.close()

    def close(self):
        self.close_logfile()


    def get_tool_name(self, tool_invoked):
        if tool_invoked == self.CLAMSCAN:
            return self.CLAMSCAN_NAME
        elif tool_invoked == self.SAVSCAN:
            return self.SAVSCAN_NAME
        elif tool_invoked == self.CMDSCAN:
            return self.CMDSCAN_NAME
        elif tool_invoked == self.FPSCAN:
            return self.FPSCAN_NAME
        else:
            return ""

    def compile_version_regex_list(self, tool_invoked):
        if tool_invoked == self.CLAMSCAN:
            return [re.compile(self.clamscan_version_regex)]
        if tool_invoked == self.SAVSCAN:
            return [re.compile(self.savscan_version_regex_1), re.compile(self.savscan_version_regex_2),
                    re.compile(self.savscan_version_regex_3)]
        if tool_invoked == self.FPSCAN:
            return [re.compile(self.fpscan_version_regex_1), re.compile(self.fpscan_version_regex_2),
                    re.compile(self.fpscan_version_regex_3)]
        else:
            return {}

    def get_version_command(self, tool_invoked):
        if tool_invoked == self.CLAMSCAN:
            return self.CLAMSCAN_VERSION_COMMAND
        elif tool_invoked == self.SAVSCAN:
            return self.SAVSCAN_VERSION_COMMAND
        # note - at the time of development, CMDSCAN has no version information
        elif tool_invoked == self.CMDSCAN:
            return self.CMDSCAN_VERSION_COMMANDD
        elif tool_invoked == self.FPSCAN:
            return self.FPSCAN_VERSION_COMMAND
        else:
            return ""

    def process_version_output(self, compiled_regex_list, output_block, tool_invoked):
        new_item = []
        for compiled_regex in compiled_regex_list:
            matches = {}
            for line in output_block.split("\n"):
                matches = compiled_regex.match(line)
                if matches:
                    if (tool_invoked == self.CLAMSCAN):
                        new_item = [matches.group(1), "", matches.group(2)]
                    elif (tool_invoked == self.SAVSCAN) or (tool_invoked == self.FPSCAN):
                        new_item.append(matches.group(1))
                    break
        return new_item

    def get_version_info(self, tool_invoked):
        version_process = []
        tool_name = self.get_tool_name(tool_invoked)
        self.logfile.write("Attempting to determine version of tool {}\n".format(tool_name))
        if tool_invoked == self.CMDSCAN:
            self.logfile.write("\tTool {} currently provides no version / virus definition information from the command"
                               " line\n".format(tool_name))
            return ["N/A", "", "N/A"]
        command = self.get_version_command(tool_invoked)
        if command:
            version_process = run(command, shell=True, encoding='utf-8', stdout=PIPE)
        if version_process:
            self.logfile.write("*** BEGIN TOOL {} OUTPUT ***\n".format(self.get_tool_name(tool_invoked)))
            for line in version_process.stdout.split('\n'):
                self.logfile.write(line + "\n")
            self.logfile.write("*** END TOOL {} OUTPUT ***\n".format(self.get_tool_name(tool_invoked)))
            version_regex_list = self.compile_version_regex_list(tool_invoked)
            processed_output = self.process_version_output(version_regex_list, version_process.stdout, tool_invoked)
            self.logfile.write("\tTool {} version information retrieved\n".format(tool_name))
            return processed_output
        return ""

    def generate_headers(self, tool_invoked):
        if tool_invoked in self.output_headers:
            return False
        else:
            tool_headers = [self.get_tool_name(tool_invoked), self.get_tool_command(tool_invoked)]
            version_headers = self.get_version_info(tool_invoked)
            tool_headers.extend(version_headers)
            self.output_headers[tool_invoked] = tool_headers
            return True

    def get_tool_command(self, tool_invoked):
        if tool_invoked == self.CLAMSCAN:
            return self.CLAMSCAN_COMMAND
        elif tool_invoked == self.SAVSCAN:
            return self.SAVSCAN_COMMAND
        elif tool_invoked == self.CMDSCAN:
            return self.CMDSCAN_COMMAND
        elif tool_invoked == self.FPSCAN:
            return self.FPSCAN_COMMAND
        else:
            return ""

    def compile_tool_regex(self, tool_invoked):
        if tool_invoked == self.CLAMSCAN:
            return re.compile(self.clamscan_regex)
        if tool_invoked == self.SAVSCAN:
            return re.compile(self.savscan_regex)
        if tool_invoked == self.CMDSCAN:
            return re.compile(self.cmdscan_regex)
        if tool_invoked == self.FPSCAN:
            return re.compile(self.fpscan_regex)
        else:
            return {}

    def get_tool_command_arguments(self, tool_invoked, evidence_file):
        return self.get_tool_command(tool_invoked) + " {}".format(evidence_file)

    def process_tool_output(self, compiled_regex, output_block, tool_invoked):
        match_output = []
        for line in output_block.split('\n'):
            matches = compiled_regex.match(line)
            if matches:
                new_item = []
                if not (tool_invoked in self.output_headers):
                    self.generate_headers(tool_invoked)
                headers = self.output_headers[tool_invoked]
                new_item.extend(headers)
                if (tool_invoked == self.CLAMSCAN) or (tool_invoked == self.CMDSCAN):
                    new_item.extend([matches.group(1), matches.group(2)])
                elif (tool_invoked == self.SAVSCAN) or (tool_invoked == self.FPSCAN):
                    new_item.extend([matches.group(2), matches.group(1)])
                match_output.append(new_item)
        return match_output


    def execute_tool_test(self, tool_invoked, evidence_file):
        tool_process = 0
        tool_name = self.get_tool_name(tool_invoked)
        self.logfile.write("Attempting to invoke tool {} on {}\n".format(tool_name, evidence_file))
        command = self.get_tool_command_arguments(tool_invoked, evidence_file)
        if command:
            tool_process = run(command, shell=True, encoding='utf-8', stdout=PIPE)
        if tool_process:
            self.logfile.write("*** BEGIN TOOL {} OUTPUT ***\n".format(self.get_tool_name(tool_invoked)))
            for line in tool_process.stdout.split('\n'):
                self.logfile.write(line + "\n")
            self.logfile.write("*** END TOOL {} OUTPUT ***\n".format(self.get_tool_name(tool_invoked)))
            tool_regex = self.compile_tool_regex(tool_invoked)
            processed_output = self.process_tool_output(tool_regex, tool_process.stdout, tool_invoked)
            self.logfile.write("\tTool {} successfully invoked on {}\n".format(tool_name, evidence_file))
            return processed_output
        return ""
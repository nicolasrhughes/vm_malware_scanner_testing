import re
from subprocess import run, PIPE
from sys import stdout
from os import path


class VirusScannerTesting:

    MIN_VIRUS_SCANNER = CLAMDSCAN = 0
    CLAMSCAN = 1
    SAVSCAN = 2
    CMDSCAN = 3
    MAX_VIRUS_SCANNER = FPSCAN = 4

    CLAMDSCAN_NAME = 'clamdscan'
    CLAMSCAN_NAME = 'clamscan'
    SAVSCAN_NAME = 'savscan'
    CMDSCAN_NAME = 'cmdscan'
    FPSCAN_NAME = 'fpscan'

    CLAMDSCAN_COMMAND = 'clamdscan --fdpass -m -i --no-summary'
    CLAMSCAN_COMMAND = 'clamscan -r -i --no-summary'
    SAVSCAN_COMMAND = 'savscan -ndi -ss {}'
    CMDSCAN_COMMAND = 'cmdscan -v -s'
    FPSCAN_COMMAND = 'fpscan -v 0 --report'

    CLAMDSCAN_VERSION_COMMAND = 'clamdscan -V'
    CLAMSCAN_VERSION_COMMAND = 'clamscan -V'
    SAVSCAN_VERSION_COMMAND = 'savscan -V'
    # Note - at time of development, no version information available for CMDSCAN
    CMDSCAN_VERSION_COMMAND = ''
    FPSCAN_VERSION_COMMAND = 'fpscan --version'

    clamdscan_regex  = clamscan_regex = """^(.*):(.*) FOUND$"""
    savscan_regex = """^>>> Virus '(.*)' found in file (.*)$"""
    cmdscan_regex = """^(.*) ---> Found .* Name is(.*)$"""
    fpscan_regex = """\[Found.*\]\s<(.*\))>\s*(/.*)"""

    savscan_version_regex_1 = """^Product version\s*:\s([0-9.]+[0-9.]+[0-9])"""
    savscan_version_regex_2 = """Engine version\s*:\s*([0-9.]+[0-9.]+[0-9])"""
    savscan_version_regex_3 = """Virus data version \s*:\s*([0-9.]+[0-9.]+[0-9])"""
    clamscan_version_regex = clamdscan_version_regex = """ClamAV\s*([0-9.]*)\/[0-9]*\/([FMSTW].*[0-9]{4})"""
    fpscan_version_regex_1 = """^F-PROT Antivirus .* version ([0-9.]*)"""
    fpscan_version_regex_2 = """^Engine version:\s*([0-9.]*)"""
    fpscan_version_regex_3 = """^Virus signatures:\s([0-9]*)"""

    # Initialize module logfile and tool output file to STDOUT, initialize output headers
    def __init__(self):
        self.logfile = stdout
        self.output = stdout
        self.output_headers = {}

    # Specify module logfile manually
    def set_logfile(self, logfile_path):
        self.logfile = open(logfile_path, 'w')

    # Specify module logfile directory, but use default name for logfile
    def set_logfile_by_directory(self, logfile_directory):
        self.logfile = open(path.join(logfile_directory, 'virus_scanner.log'), 'w')

    # Flush module logfile
    def flush_logfile(self):
        self.logfile.flush()

    # Close module logfile
    def close_logfile(self):
        if self.logfile != stdout:
            self.logfile.close()

    # Specify tool output file
    def set_output(self, output_path):
        self.output = open(output_path, 'w')

    # Flush tool output file
    def flush_output(self):
        self.output.flush()

    # Close tool output file
    def close_output(self):
        if self.output != stdout:
            self.output.close()

    # Close all logfiles (tool output, module logs)
    def close(self):
        self.close_logfile()
        self.close_output()

    # Associate tool name string with internal value used to invoke tool
    def get_tool_id(self, tool_invoked):
        if tool_invoked == self.CLAMDSCAN_NAME:
            return self.CLAMDSCAN
        elif tool_invoked == self.CLAMSCAN_NAME:
            return self.CLAMSCAN
        elif tool_invoked == self.SAVSCAN_NAME:
            return self.SAVSCAN
        elif tool_invoked == self.CMDSCAN_NAME:
            return self.CMDSCAN
        elif tool_invoked == self.FPSCAN_NAME:
            return self.FPSCAN
        else:
            return ''

    # Get tool name string for given internal value used to invoke tool
    def get_tool_name(self, tool_invoked):
        if tool_invoked == self.CLAMDSCAN:
            return self.CLAMDSCAN_NAME
        elif tool_invoked == self.CLAMSCAN:
            return self.CLAMSCAN_NAME
        elif tool_invoked == self.SAVSCAN:
            return self.SAVSCAN_NAME
        elif tool_invoked == self.CMDSCAN:
            return self.CMDSCAN_NAME
        elif tool_invoked == self.FPSCAN:
            return self.FPSCAN_NAME
        else:
            return ''

    # Compile the regex used to parse the tool output
    def compile_version_regex_list(self, tool_invoked):
        if tool_invoked == self.CLAMDSCAN:
            return [re.compile(self.clamdscan_version_regex)]
        if tool_invoked == self.CLAMSCAN:
            return [re.compile(self.clamscan_version_regex)]
        if tool_invoked == self.SAVSCAN:
            return [re.compile(self.savscan_version_regex_1), re.compile(self.savscan_version_regex_2),
                    re.compile(self.savscan_version_regex_3)]
        if tool_invoked == self.FPSCAN:
            return [re.compile(self.fpscan_version_regex_1), re.compile(self.fpscan_version_regex_2),
                    re.compile(self.fpscan_version_regex_3)]
        else:
            return {}

    # Select the command needed to display the tool version information
    def get_version_command(self, tool_invoked):
        if tool_invoked == self.CLAMDSCAN:
            return self.CLAMDSCAN_VERSION_COMMAND
        if tool_invoked == self.CLAMSCAN:
            return self.CLAMSCAN_VERSION_COMMAND
        elif tool_invoked == self.SAVSCAN:
            return self.SAVSCAN_VERSION_COMMAND
        # note - at the time of development, CMDSCAN has no version information
        elif tool_invoked == self.CMDSCAN:
            return self.CMDSCAN_VERSION_COMMANDD
        elif tool_invoked == self.FPSCAN:
            return self.FPSCAN_VERSION_COMMAND
        else:
            return ''

    # Process tool version information, output as list
    def process_version_output(self, compiled_regex_list, output_block, tool_invoked):
        new_item = []
        for compiled_regex in compiled_regex_list:
            matches = {}
            for line in output_block.split('\n'):
                matches = compiled_regex.match(line)
                if matches:
                    if (tool_invoked == self.CLAMDSCAN) or (tool_invoked == self.CLAMSCAN):
                        new_item = [matches.group(1), '', matches.group(2)]
                    elif (tool_invoked == self.SAVSCAN) or (tool_invoked == self.FPSCAN):
                        new_item.append(matches.group(1))
                    break
        return new_item

    # Execute command needed to get tool information, process output, return list of processed version output
    def get_version_info(self, tool_invoked):
        version_process = []
        tool_name = self.get_tool_name(tool_invoked)
        self.logfile.write('Attempting to determine version of tool {}\n'.format(tool_name))
        if tool_invoked == self.CMDSCAN:
            self.logfile.write('\tTool {} currently provides no version / virus definition information from the command'
                               ' line\n'.format(tool_name))
            return ['N/A', '', 'N/A']
        command = self.get_version_command(tool_invoked)
        if command:
            version_process = run(command, shell=True, encoding='utf-8', stdout=PIPE)
        if version_process:
            self.logfile.write('*** BEGIN TOOL {} OUTPUT ***\n'.format(self.get_tool_name(tool_invoked)))
            for line in version_process.stdout.split('\n'):
                self.logfile.write(line + '\n')
            self.logfile.write('*** END TOOL {} OUTPUT ***\n'.format(self.get_tool_name(tool_invoked)))
            version_regex_list = self.compile_version_regex_list(tool_invoked)
            processed_output = self.process_version_output(version_regex_list, version_process.stdout, tool_invoked)
            self.logfile.write('\tTool {} version information retrieved\n'.format(tool_name))
            return processed_output
        return ''

    # Generate tool specific headers (the scanner, the specific command executed, and the version information). These
    # headers will be appended to the tool output
    def generate_headers(self, tool_invoked):
        if tool_invoked in self.output_headers:
            return False
        else:
            tool_headers = [self.get_tool_name(tool_invoked), self.get_tool_command(tool_invoked)]
            version_headers = self.get_version_info(tool_invoked)
            tool_headers.extend(version_headers)
            self.output_headers[tool_invoked] = tool_headers
            return True

    # Select the appropriate tool command for an internal tool association
    def get_tool_command(self, tool_invoked):
        if tool_invoked == self.CLAMDSCAN:
            return self.CLAMDSCAN_COMMAND
        elif tool_invoked == self.CLAMSCAN:
            return self.CLAMSCAN_COMMAND
        elif tool_invoked == self.SAVSCAN:
            return self.SAVSCAN_COMMAND
        elif tool_invoked == self.CMDSCAN:
            return self.CMDSCAN_COMMAND
        elif tool_invoked == self.FPSCAN:
            return self.FPSCAN_COMMAND
        else:
            return ''

    # Compile the regex used to process the tool output
    def compile_tool_regex(self, tool_invoked):
        if tool_invoked == self.CLAMDSCAN:
            return re.compile(self.clamdscan_regex)
        if tool_invoked == self.CLAMSCAN:
            return re.compile(self.clamscan_regex)
        if tool_invoked == self.SAVSCAN:
            return re.compile(self.savscan_regex)
        if tool_invoked == self.CMDSCAN:
            return re.compile(self.cmdscan_regex)
        if tool_invoked == self.FPSCAN:
            return re.compile(self.fpscan_regex)
        else:
            return []

    # This function simply combines the tool command and the directory to scan
    def get_tool_command_arguments(self, tool_invoked, evidence_file):
        return self.get_tool_command(tool_invoked) + ' {}'.format(evidence_file)

    # This function parses the tool output and appends the headers to the output
    def process_tool_output(self, compiled_regex, output_block, tool_invoked):
        match_output = []
        for line in output_block.split('\n'):
            matches = compiled_regex.match(line)
            if matches:
                new_item = []
                if not (tool_invoked in self.output_headers):
                    self.generate_headers(tool_invoked)
                headers = self.output_headers[tool_invoked]
                new_item.extend(headers)
                if (tool_invoked == self.CLAMDSCAN) or (tool_invoked == self.CLAMSCAN) or \
                        (tool_invoked == self.CMDSCAN):
                    new_item.extend([matches.group(1), matches.group(2)])
                elif (tool_invoked == self.SAVSCAN) or (tool_invoked == self.FPSCAN):
                    new_item.extend([matches.group(2), matches.group(1)])
                match_output.append(new_item)
        return match_output

    # This function writes the processed output to the tool output file (or STDOUT if none was specified)
    def write_output(self, processed_output):
        for i in range(0, len(processed_output)):
            for j in range(0, len(processed_output[i])):
                if j != len(processed_output[i]) - 1:
                    self.output.write(str(processed_output[i][j]) + ',')
                else:
                    self.output.write(str(processed_output[i][j]) + '\n')
        self.output.flush()

    # Execute the full tool test, process output, and write it to the correct file
    def execute_tool_test(self, tool_invoked, evidence_file):
        tool_process = 0
        tool_name = self.get_tool_name(tool_invoked)
        self.logfile.write('Attempting to invoke tool {} on {}\n'.format(tool_name, evidence_file))
        command = self.get_tool_command_arguments(tool_invoked, evidence_file)
        if command:
            tool_process = run(command, shell=True, encoding='utf-8', stdout=PIPE)
        if tool_process:
            self.logfile.write('*** BEGIN TOOL {} OUTPUT ***\n'.format(self.get_tool_name(tool_invoked)))
            for line in tool_process.stdout.split('\n'):
                self.logfile.write(line + '\n')
            self.logfile.write('*** END TOOL {} OUTPUT ***\n'.format(self.get_tool_name(tool_invoked)))
            tool_regex = self.compile_tool_regex(tool_invoked)
            processed_output = self.process_tool_output(tool_regex, tool_process.stdout, tool_invoked)
            self.write_output(processed_output)
            self.logfile.write('\tTool {} successfully invoked on {}\n'.format(tool_name, evidence_file))
            return True
        return False
